# 1．Jquery

## 1.1. js不好的地方

| 序号 | 缺点                                  |
| ---- | ------------------------------------- |
| 1    | 代码冗余，需要遍历，可能还需要嵌套    |
| 2    | 找对象麻烦，方法少，使用麻烦          |
| 3    | 有兼容性问题                          |
| 4    | 实现简单的动画时，需要使用animate对象 |
| 5    | 注册事件会被覆盖(后面的会覆盖前面的)  |

## 1.2  jquery初体验

首先引入jquery.js文件:

<script type="text/javascript" src="jquery-1.12.4.js"></script>
然后建立jquery入口，并在内部建立：

```javascript
$(document).ready();//代表HTML文档准备好，是jquery入口的标准写法

$(document).ready(function() {
   console.log('hello jquery');
});
```

//function写在ready中

Jquery对Microsoft和Google很支持，如果不想引入本地的jquery文件，可以通过Google或Microsoft引入jquery文件。

Google:

<script type=’text/javascript’ src=’http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js’></script>
Microsoft:

<script type=’text/javascript’ src=’http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js’></script>
## 1.3. 元素选择器

> Jquery元素选择器和属性选择器允许使用标签名、属性、内容对HTML元素进行选择。

| 表现形式   | 作用                     |
| ---------- | ------------------------ |
| $(“p”)     | 查找标签元素<p>          |
| $(“.demo”) | 查找`class=”demo”`的元素 |
| $(“#demo”) | 查找`id=”demo”`的元素    |

## 1.4. 注册事件

`$("#color").click(function() {
​    $("div").show();
});`

为`id=”color”`的元素注册点击事件(click),function内部是事件具体内容。

在事件这一部分，与js不同的是只需要去除on即可。Js与jquery在事件这一部分只差一个on。

## 1.5. 关于循环

> Jquery会自动迭代，不需要自己迭代。

## 1.6. 入口函数

Jquery入口函数有2种，分别是:

```javascript
$(function(){
    console.log("jquery的第二种入口");
});

$(document).ready(function() {
    console.log("jquery第一种入口");
});
```

> Jquery的入口函数与js的入口函数`window.onload()`,都会等待文档加载完成才执行，但是jquery的入口函数不会等待图片的加载。

## 1.7. 动画

### 1.7.1. 显示、隐藏

```javascript
$("p").show();//显示，显示已被隐藏的元素
$("p").hide();//隐藏，隐藏正在显示的元素
```

> 定义与语法

语法：`$(selector).show(speed,callback)`

| 参数     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| speed    | <p>可选。规定元素从隐藏到完全可见的速度。默认为 "0"。</p>    |
|          | 可能的值：                                                   |
|          | 毫秒 （比如 1500）, "slow" ,"normal", "fast"                 |
|          | 在设置速度的情况下，元素从隐藏到完全可见的过程中，会逐渐地改变其高度、宽度、外边距、内边距和透明度。 |
| callback | 可选。show 函数执行完之后，要执行的函数。                    |
|          | 如需学习更多有关 callback 的内容，请访问我们的 jQuery Callback 这一章。 |
|          | 除非设置了 speed 参数，否则不能设置该参数。                  |

> *提示*：如果元素已经是完全可见，则该效果不产生任何变化，除非规定了 callback 函数。

*注释*：该效果适用于通过 jQuery 隐藏的元素，或在 CSS 中声明 display:none 的元素（但不适用于 visibility:hidden 的元素）。

### 1.7.2. 滑入、滑出、切换

```javascript
$("div").slideUp(1000);//滑入，从下向上收缩元素
$("div").slideDown(1000);//划出，从上向下伸展元素
$("div").slideToggle(1000);//切换，元素每点击一次，便会在滑入与滑出状态间切换一次
```

> 定义与语法与显示隐藏相同

### 1.7.3. 淡入、淡出、切换

```javascript
$("div").fadeIn(1000);//淡入，元素透明度从0到1
$("div").fadeOut(1000);//淡出，元素透明度从1到0
$("div").fadeToggle(1000);//切换，元素每点击一次，便会在淡入或淡出状态间切换一次
```

> 定义与语法与显示隐藏相同

### 1.7.4. 自定义动画animate

```javascript
$("div").animate({left:800}, 2000, "linear", function(){
                console.log("yooo, jquery!");
            });
```

> 定义与语法

| 位置 | 含义                   | 作用                                           |
| ---- | ---------------------- | ---------------------------------------------- |
| 1    | 元素的样式，是一个数组 | 代表元素从现在的样式将会变化为被定义的样式     |
| 2    | 变化的速度             | 代表元素从开始到结束的时间                     |
| 3    | 变化的快慢             | 可选参数："swing"(秋千/摇摆)、"linear"(匀加速) |
| 4    | 回调函数callback       | 完成动画后执行函数                             |

### 1.7.5. 停止动画stop

```javascript
$div.stop(false, true);
```

> 定义与语法

| 参数位置 | 选项       | 效果                           |
| -------- | ---------- | ------------------------------ |
| 1        | true/false | 是否停止当前动画并清除动画队列 |
| 2        | true/false | 是否显示当前动画的最终动画效果 |

### 1.7.6. delay

> 效果：延迟动画的播放

```javascript
$("div").fadeIn(1000).delay(1000).fadeOut(1000);
//效果是div将会在1s内以淡入的动画出现，然后维持2s，最后在1s内以淡出的动画隐藏
```



## 1.8. text和html

### 1.8.1. text()

> 实例

```javascript
$("div").text("<p>我是文本2。</p>")//设置p元素的内容,将div元素设置为‘<p>我是文本2。</p>’ 
$("div").text()//获取div元素的内容，不包含div元素内的标签元素
```

> 定义

设置和获取被选元素的文本内容，文本内容不会识别标签元素，一律视为字符串。

### 1.8.2. html()

> 示例

```javascript
$("div").html()//获取div元素的内容，包含div元素内部的标签元素
$("div").html("<p>我是文本。</p>")
//设置div元素的内容，将div元素的内容设置为一个值为‘我是文本。’的p标签
```

## 1.9. jquery与dom对象

*a*  : dom对象是一个对象(dom对象即js对象)，jquery对象是一个伪数组，里面是js对象；

*b*  :dom对象与jquery对象不能使用对方的方法，例如：

```javascript
var btn = document.getElementById('btn');
btn.onclick = function(){};
var $btn = $('#btn');//btn是专门用于js对象，$btn是用于jquery对象
$btn.onclick = function(){};//$btn.onclick无法生效
$btn[0].onclick = function(){};//$btn[0].onclick可以生效
//jquery转dom对象方法是$btn[0]，即取出一个js对象即可，类似的方法还有$btn.get(0)
//dom对象转jquery对象方法是$(btn)，即将dom对象置于$()中即可
```

## 1.10. 操作样式

### 1.10.1. 修改单个css样式

```javascript
//css(name, value);name指需要修改的css的名字，value是对应的值
$("#btn").css("backgroundColor","red");
```

### 1.10.2. 修改多个css样式

```javascript
$("li").css({
    "backgroundColor": "lightblue",
    "border": "1px solid black"
});
```

### 1.10.3. 获取css样式

```javascript
$("li").css("backgroundColor")
```

## 1.11. 鼠标悬浮事件

| 方法                      | 区别                                                 |
| ------------------------- | ---------------------------------------------------- |
| mouseover()-mouseout()    | 鼠标指针先经过事件元素然后事件元素的子元素算经过两次 |
| mouseenter()-mouseleave() | 鼠标指针先经过事件元素然后事件元素的子元素只算一次   |

## 1.12. 层级选择器

| 选择器     | 表现形式   | 作用                       |
| ---------- | ---------- | -------------------------- |
| 并集选择器 | $("s1,s2") | 查找元素内有s1或s2的元素   |
| 后代选择器 | $("s1 s2") | 查找位于元素s1内部的s2元素 |
| 子代选择器 | $("s1>s2") | 查找与元素s1挨着的s2元素   |
| 交集选择器 | $("s1s2")  | 查找元素有s1且有s2的元素   |

## 1.13. 过滤选择器

```javascript
 $(function () {
        //下标从0开始
        $("li:even").css("backgroundColor", "red");//下标是偶数的
        $("li:odd").css("backgroundColor", "lightblue");//下标是奇数的
        $("li:first").css("fontSize", "30px");//下标是第一个的
        $("li:last").css("width", "100px");//下标是最后一个的
        $("li:eq(8)").css("width", "200px");//下标等于8的
        $("li:gt(5)").css("color", "white");//下标大于5的
        $("li:lt(5)").css("color", "pink");//下标小于5的
  });
```

## 1.14. 表单选择器

| 表现形式 | 作用                       |
| -------- | -------------------------- |
| input    | 选择输入框元素             |
| password | 选择密码输入框元素         |
| text     | 选择文本输入框元素         |
| radio    | 选择单选框元素             |
| checkbox | 选择复选框元素             |
| submit   | 选择提交按钮元素           |
| image    | 选择图片元素               |
| reset    | 选择重置按钮元素           |
| button   | 选择按钮元素               |
| file     | 选择文件元素               |
| hidden   | 选择隐藏元素               |
| enabled  | 选择禁用元素               |
| disabled | 选择可用元素               |
| checked  | 选择被选中的单选框或复选框 |
| selected | 选择被选中的下拉框         |

## 1.15. 筛选选择器

| 选择器     | 作用                                                         | demo                    |
| ---------- | ------------------------------------------------------------ | ----------------------- |
| children() | 查找某元素的子元素                                           | $(this).children("ul")  |
| siblings() | 查找某元素的兄弟元素（不包含自已）                           | $(this).siblings("li")  |
| find("li") | 在某元素的子元素中查找指定的元素                             | $(this).find("li")      |
| next()     | 查找某元素的下一个元素（是否必须是同级元素）                 | $(this).next("div")     |
| parent()   | 查找某元素的父级元素                                         | $(this).parent("li")    |
| prevAll()  | 查找某元素前面的所有元素                                     | $(this).prevAll()       |
| nextAll()  | 查找某元素后面的元素                                         | $(this).nextAll()       |
| end()      | 结束上一个查找元素方法prevAll()的效果，让上上一个查找元素的方法$(this)再次生效 | $(this).prevAll().end() |

## 1.16. 操作class（类）

### 1.16.1 . 添加类

```javascript
$("li").addClass("basic");
```

### 1.16.2. 删除类

```javascript
$("li").removeClass("basic");
```

### 1.16.3. 切换类的有无

> 当元素中有某个类时，将会删除这个类；当元素没有这个类时，将会添加这个类；

```javascript
 $("li").toggleClass("basic");
```

### 1.16.4. 判断类的有无

```javascript
$("li").hasClass("basic");
```

## 1.17. 操作属性

### 1.17.1. 修改单个属性

```javascript
$("img").attr("alt", "灵梦1号");
```

### 1.17.2. 修改多个属性

```javascript
$("img").attr({
            "alt": "灵梦2号",
            "title": "东方幻想乡",
    		"aaa": "bbb"
        });
```

### 1.17.3. 获取属性

```javascript
$("img").attr("alt");
```

> 注意：在。jquery1.6之后，对于checkbox的input的checked属性，attr将会出现问题，需要使用其他的方法(prop方法)进行替代。原因是attr对布尔类型的属性无法操作。
>

```javascript
$("input").prop("checked", true);
$("input").prop("checked");
```

### 1.17.4. 移除单个属性

```javascript
$("img").removeAttr("title");//移除图片的标题属性
```

## 1.18. 操作音频

> 方法 

| 方法         | 作用                                                         | 演示           |
| ------------ | ------------------------------------------------------------ | -------------- |
| load()       | 控制加载                                                     | m.load()       |
| play()       | 控制播放                                                     | m.play()       |
| pause()      | 控制暂停                                                     | m.pause()      |
| fastSeek(20) | 指定播放时间，这样的话，音频会定位到20秒的播放位置。不过目前只有Firefox浏览器支持，你可以通过currentTime属性来实现。 | m.fastSeek(20) |

> 属性 

| 属性        | 作用                                                         | 演示              |
| ----------- | ------------------------------------------------------------ | ----------------- |
| currentTime | 获取和设置已播放的时间，返回的数字以( s )秒为单位            | m.currentTime=10  |
| autoplay    | 是否自动播放                                                 | m.autoplay = true |
| loop        | 是否循环播放                                                 | m.loop = true     |
| controls    | 是否显示控制面板                                             | m.controls = true |
| muted       | 是否静音                                                     | m.muted = true    |
| paused      | 是否暂停，判断音频当前是否暂停，返回true代表暂停，返回false代表正在播放；**默认是true；该值只能读取，不能修改**。 | m.paused          |
| volume      | 调节音量，音量的取值范围在：**0（无声）~1（最大声）之间**。可以对volume属性赋合理的值或者做一些运算，来改变音频的音量。 | m.volume = 0.1    |

## 1.19. 添加节点

> 方法

| 方法       | 演示               | 结果                                 |
| ---------- | ------------------ | ------------------------------------ |
| append()   | $div.append($p)    | 将p元素加在div元素的元素内部的最后面 |
| prepend()  | $div.prepend($p)   | 将p元素加在div元素的元素内部的最前面 |
| appendTo() | $div.appendTo($p)  | 将div元素加在p元素的元素内部的最后面 |
| after()    | $p.after($div)     | 将div元素加在p元素的元素外部后面     |
| before()   | $div.before($p)    | 将div元素加在p元素的元素外部前面     |
| $()        | $("<span></span>") | 创建一个span元素                     |

## 1.20. 节点的删除克隆

> 方法

| 方法     | 演示                      | 作用                                                         | 范围                 |
| -------- | ------------------------- | ------------------------------------------------------------ | -------------------- |
| html()   | $div.html("")             | 可以清空节点，会造成内存泄漏（只清空div内部节点并将其置为空，未清除内部节点相关事件） | 用于从父节点清空元素 |
| empty()  | $div.empty()              | 可以清空节点，不会造成内存泄漏（清空div内部节点并清除内部节点相关事件） | 用于从父节点清空元素 |
| remove() | $div.remove()             | 删除自己这个节点与相关事件                                   | 用于移除自身元素     |
| clone()  | $p.clone().appendTo($div) | 克隆自身节点                                                 | 用于克隆自身元素     |

> 注意

clone()可以传入参数true/false，默认参数是false。传入true时，会进行深度复制，而且会复制元素相关事件；传入false时，只会进行深度复制，不会复制元素相关事件。

## 1.21. val

> 用于获取和设置text、textarea等可输入内容的元素的值。

```javascript
$txt.val("洋酒");//设置元素内容
$txt.val();//获取元素内容
```

## 1.22. width和height

### 1.22.1. 设置元素的宽度

| 方法         | 演示                   | 效果                                                |
| ------------ | ---------------------- | --------------------------------------------------- |
| width()      | $div.width()           | 获取div元素的width                                  |
|              | $div.width(400)        | 设置div元素的width为400px                           |
| innerWidth() | $div.innerWidth()      | 获取div元素的width与padding的和                     |
| outerWidth() | $div.outerWidth(false) | 获取div元素的width、padding、border三者之和         |
|              | $div.outerWidth(true)  | 获取div元素的width、padding、border、margin四者之和 |

### 1.22.2. 设置元素高度

| 方法          | 演示                    | 效果                                                 |
| ------------- | ----------------------- | ---------------------------------------------------- |
| height()      | $div.height()           | 获取div元素的height                                  |
|               | $div.height(400)        | 设置div元素的height为400px                           |
| innerHeight() | $div.innerHeight()      | 获取div元素的height与padding的和                     |
| outerHeight() | $div.outerHeight(false) | 获取div元素的height、padding、border三者之和         |
|               | $div.outerHeight(true)  | 获取div元素的height、padding、border、margin四者之和 |

### 1.22.3. 获取屏幕宽高

```javascript
$(window).width();//宽度
$(window).height();//高度
```

## 1.23. scrollTop和scrollLeft

> 例子

```javascript
$window.scroll(function(){						//注册滚动条滚动事件
            console.log($window.scrollTop());	//打印竖向滚动条的位置
            console.log($window.scrollLeft());	//打印横向滚动条的位置
 });
//屏幕向下滑动时在控制台打印坐标，向右滑动时同样打印。
```

> 兼容性

```javascript
$("html,body").animate({scrollTop: 0}, 2000);
//注册动画，当浏览器为ie6，7，8时，用html；火狐谷歌用body
```

## 1.24. offset与position

```javascript
console.log($(".son").offset().top);	//打印自身相对于document的位置
console.log($(".son").position().left); //打印自身相对于有定位的父元素的位置
```

## 1.25. 事件委托机制

简单事件绑定>bind事件绑定>delegate事件绑定>on事件绑定（推荐）

### 1.25.1. click和onclick

```javascript
$("p").click(function(){ 
    alert("111");
});
```

> 缺点：一次注册一个事件

### 1.25.2. bind

```javascript
$("p").click(function(){
     alert("111");
});
//一次注册一个事件
 $("p").bind("click mouseenter", function(){
     alert("222");
 });
//一次为不同的动作注册同一的事件
$("p").bind({"click":function(){
    alert("333");
},"mouseenter":function(){
    alert("444");
}});
//一次为不同动作注册不同的事件
```

> 注意：上述两种事件注册方式共有的缺点就是只能为已有元素注册事件，注册完事件后新增的元素并不会被注册事件。只能为自己这个元素注册事件的事件机制称为简单事件机制。

### 1.25.3 delegate

```javascript
$("div").delegate("p", "click", function(){
    alert("555");
});
```

可以为内部子元素注册事件。

> 参数含义

| 位置   | 作用                                |
| ------ | ----------------------------------- |
| 第一个 | 填写选择器                          |
| 第二个 | 填写事件类型（ 如click,mouseenter） |
| 第三个 | 非必填项                            |
| 第四个 | 事件发生时需要执行的函数            |

> 委托机制原理

​	首先向父元素注册事件，然后当元素被触发事件时，会向上传递给父元素，父元素将会为其注册事件，最后该事件引动函数。类似的例子有快递员给人发货，会先发给快递之家，然后有快递之家发送给具体的人。

### 1.25.4. on

```javascript
$("button").on("click", function(){ //为自身元素注册事件
    $("<p>我是新的p元素。</p>").appendTo("div");
});
$("div").on("click", "p", function(){//为内部子元素注册事件
    alert("222");
});
```

> 参数含义

| 位置   | 作用                                     |
| ------ | ---------------------------------------- |
| 第一个 | 填写事件类型（ 如click,mouseenter）      |
| 第二个 | 填写选择器（必须是注册事件元素的子元素） |
| 第三个 | 非必填项                                 |
| 第四个 | 事件发生时需要执行的函数                 |

委托机制原理与delegate相似。

### 1.25.5. off

```javascript
$("p").on("mouseenter click", function(){//为p元素注册点击与鼠标经过事件
    alert("1111");
});
$("p").off("mouseenter");//将p元素的鼠标经过事件移除
```

> 效果：p元素只剩点击事件

### 1.25.6. trigger

```javascript
$("p").on("mouseenter click", function(){//为p元素注册点击与鼠标经过事件
    alert("1111");
});
$("#btn").on("click", function(){//为button元素注册点击事件
    // $("p").click();		//按钮被点击时，触发p元素的点击事件
    $("p").trigger("click");//按钮被点击时，触发p元素的点击事件
});
```

## 1.26. 阻止事件冒泡与默认行为

```javascript
$("a").on("click", function(){
    alert("111");
    e.preventDefault();//阻止元素的默认行为
    e.stopPropagation();//阻止元素的冒泡行为
    //return false; //同时阻止元素的默认行为和冒泡行为
});
```

## 1.27. each

```javascript
for(var i=0;i<$("li").length;i++){
    $("li").eq(i).css("opacity", (i+1)/10);
}
$("li").each(function(index, element){
    $(element).css("opacity", (index+1)/10);
});
//上下效果相同，将10个li依次排开，并且透明度逐渐增加，从0到1
```

## 1.28. noConflict

> $的冲突

当引入2个不同的js文件时，如果二者都需要使用$,则必然会产生冲突。为解决冲突可通过noConflict()方法释放$的控制权，改为jQuery获得控制权，或者通过noConflict()方法换一个变量控制jquery。

```javascript
<script src='new.js'></script>//引入另一个使用$的js文件
<script src='jquery-1.12.4.js'></script>//引入jquery.js文件
<script>
	 var c = $.no.noConflict();//1.释放$的控制权，改为由c控制jquery
jQuery(function(){//2.用jQuery代替$控制jquery
    
});
</script>
```

## 1.29. 引入插件color

```javascript
<script src="jquery-1.12.4.js"></script>
<script src="jquery-2.1.2.color.js"></script>
<script>
    $(function(){
        $("div").animate({backgroundColor: "green"}, 3000, function(){
            alert("hello");
        });
    });
</script>
//插件只需引入就可以起作用
```

## 1.30. 引入插件lazyload

```javascript
<body>
<img class="lazy" data-original="images/a.jpg" alt="">//2.将图片src改为data-original

<script src="jquery-1.12.4.js"></script>
<script src="jquery.lazyload.js"></script>//1.引入js文件
<script>
    $(function(){
        $("img.lazy").lazyload();//3.调用lazyload方法
    });
</script>
//作用：当页面图片过多时，可以使图片可以暂时不加载，等到需要时再加载。
```

## 1.31.引入插件ui

> 增加了js对css的操作部分

```javascript
script src="jquery-1.12.4.js"></script>
<script src="jquery-ui.js"></script>
<script>
    $(function(){
        $(".container").draggable({//整个div可拖动
            handle: ".top"		   //限制为只有顶部导航栏可拖动这个div
        });
        $("ul").sortable({			//ul内部的li可通过拖动进行排序
            opacity: 0.3			//拖动li时，将其透明度变为0.3
        });
        $(".resize").resizable({	//div可扩展大小
            minHeight: 160,			//限制最小高度为160px
            handles: "s"			//限制只有div下面可拖动
        });
    });
```

## 1.32. 制作插件

```javascript
$.fn.bgColor = function(color){
    this.css("backgroundColor", color); //this代表使用这个方法的元素
    return this;	//返回this是为了链式编程可以进行下去
};
//bgColor为方法名称,function为其内容，可传参数
//使用时需先引入jquery，再引入自己做的插件
```





# 2． HTML

## 2.1. Idea快捷键

### 2.1.1. div*3(按tab生效)

* 效果：

```html
<div></div>
<div></div>
<div></div>
```

### 2.1.2. shift+Enter

 * 作用：在当前行下方生成新的一行，并且光标下移到新的这一行。

### 2.1.3. ul>li{我是第$个li}*10

* 效果：

  ```javas
  <ul>
      <li>我是第1个li</li>
      <li>我是第2个li</li>
      <li>我是第3个li</li>
      <li>我是第4个li</li>
      <li>我是第5个li</li>
      <li>我是第6个li</li>
      <li>我是第7个li</li>
      <li>我是第8个li</li>
      <li>我是第9个li</li>
      <li>我是第10个li</li>
  </ul>
  ```

### 2.1.4. ctrl+d

* 作用：向下复制当前行内容

### 2.1.5. ctrl+shift+/

* 作用：注释被选中部分。

### 2.1.6. ctrl+/

* 作用：分别注释被选中的每一行。

## 2.2. 无序序列ul

> *a*   :如何让无序序列的序号消失？

```css
<style type='text/css'>
li{
    list-style:none;
}
</style>
```

## 2.3. 音频audio

> 定义

定义声音，比如音乐或其他音频流。

> 示例

```html
<audio src="mp3/1.mp3" controls></audio>
```

> 属性

| 属性     | 值             | 描述                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| autoplay | autoplay       | 如果出现该属性，则音频在就绪后马上播放。                     |
| controls | controls       | 如果出现该属性，则向用户显示控件，比如播放按钮。             |
| preload  | auto,meta,none | 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。 |
| loop     | loop           | 如果出现该属性，则每当音频结束时重新开始播放。               |
| src      | url            | 要播放的音频的 URL。                                         |
| muted    | muted          | 加了muted属性，**音频即使在播放的时候，也是没有声音**，除非用户手动调整控制面板的音量。 |

> 提示

可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。

## 2.4. 视频video

> 定义

定义视频，比如电影片段或其他视频流。

> 提示

可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。

> 示例

```html
<video src="movie.ogg" controls="controls">
您的浏览器不支持 video 标签。
</video>
<video>
        <source src="movie.mp4" type="video/mp4">
        <source src="movie.ogg" type="video/ogg">
        浏览器太老啦，该换了！
 </video>
```

> 属性

| 属性     | 值       | 描述                                                         |
| -------- | -------- | ------------------------------------------------------------ |
| autoplay | autoplay | 如果出现该属性，则视频在就绪后马上播放。                     |
| controls | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。             |
| height   | pixels   | 设置视频播放器的高度。                                       |
| loop     | loop     | 如果出现该属性，则当媒介文件完成播放后再次开始播放。         |
| preload  | preload  | 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。 |
| src      | *url*    | 要播放的视频的 URL。                                         |
| width    | *pixels* | 设置视频播放器的宽度。                                       |

## 2.5. 表格table

> 示例

```html
<table border="1">
  <tr>
    <th>Month</th>
    <th>Savings</th>
  </tr>
  <tr>
    <td>January</td>
    <td>$100</td>
  </tr>
</table>
```

> 效果

![1551236855439](E:\typora-document\images\1551236855439.png)

> 定义与语法

<table> 标签定义 HTML 表格。

简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成。

tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元。

更复杂的 HTML 表格也可能包括 caption、col、colgroup、thead、tfoot 以及 tbody 元素。

> 属性

| 属性                                                         | 值                                                        | 描述                                                         |
| ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |
| [align](http://www.w3school.com.cn/tags/att_table_align.asp) | left、center、right                                       | 不赞成使用。请使用样式代替。规定表格相对周围元素的对齐方式。 |
| [bgcolor](http://www.w3school.com.cn/tags/att_table_bgcolor.asp) | rgb(x,x,x)、#xxxxxx、colorname                            | 不赞成使用。请使用样式代替。规定表格的背景颜色。             |
| [border](http://www.w3school.com.cn/tags/att_table_border.asp) | 数字                                                      | 规定表格边框的宽度。                                         |
| [cellpadding](http://www.w3school.com.cn/tags/att_table_cellpadding.asp) | 百分数、数字                                              | 规定单元边沿与其内容之间的空白。                             |
| [cellspacing](http://www.w3school.com.cn/tags/att_table_cellspacing.asp) | 百分数、数字                                              | 规定单元格之间的空白。                                       |
| [frame](http://www.w3school.com.cn/tags/att_table_frame.asp) | void、above、below、hsides、lhs、rhs、vsides、box、border | 规定外侧边框的哪个部分是可见的。                             |
| [rules](http://www.w3school.com.cn/tags/att_table_rules.asp) | nonegroupsrowscolsall                                     | 规定内侧边框的哪个部分是可见的。                             |
| [summary](http://www.w3school.com.cn/tags/att_table_summary.asp) | text                                                      | 规定表格的摘要。                                             |
| [width](http://www.w3school.com.cn/tags/att_table_width.asp) | 百分数、数字                                              | 规定表格的宽度。                                             |

# 3． Css

## 3.1. 开头

```html
<style type="text/css">
    div{
        height:100px;
        background-color: #ddd;
        border: 1px solid #fff;
        margin: 50px 0px;
        display: none;
    }
</style>
```



## 3.2. display

> 定义

display 属性规定元素应该生成的框的类型。

### 可能的值

| 值                 | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| none               | 此元素不会被显示。                                           |
| block              | 此元素将显示为块级元素，此元素前后会带有换行符。             |
| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。         |
| inline-block       | 行内块元素。（CSS2.1 新增的值）                              |
| list-item          | 此元素会作为列表显示。                                       |
| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。               |
| compact            | CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |
| marker             | CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |
| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。       |
| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。       |
| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。       |
| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                    |
| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。    |
| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                   |
| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |
| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）               |
| inherit            | 规定应该从父元素继承 display 属性的值。                      |

## 3.3. position

> position只是针对自身相对于父级元素的定位，而不是针对自身内部元素在自己内部的定位。

### 3.3.1. absolute

> 定义：

生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

> 解释：

相对于元素最近的已定位的祖先元素（即是设置了绝对定位或者相对定位的祖先元素）。

> 注释：

绝对定位本身与文档流无关，因此不占空间，普通文档流中的元素的布局就当绝对定位的元素不存时一样，所以 它们可以覆盖页面上其他的元素，且可以通过z-index属性来控制这些层的对方顺序。

> 注意

position:absolute，float会隐式地改变display的类型（display：none除外）。即是当元素设置position:absolute、float:left、float:right中任意一个时，都会让元素以display:inline-block的方式显示（特点是：可以设置长宽，默认宽度不占满父元素）。这时，即使故意设置display:inline; display:block都是无效的。但是float在IE6下的双边距bug就是用display:inline; 来解决的。position:relative不会隐式改变display的类型。

### 3.3.2. relative

> 定义：

生成相对定位的元素，相对于其正常位置进行定位。

> 解释：

相对定位是相对于元素在文档中的初始位置——首先它出现在它所在的位置上（即不设置position时的位置，然后通过设置垂直或水平位置，让这个元素“相对于”它的原始起点进行移动；

> 注意：

在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。

### 3.3.3. static

> 定义：

默认值。没有定位，元素出现在正常的位置中.

### 3.3.4. fixed

> 定义

生成绝对定位的元素，相对于浏览器窗口进行定位。

### 3.3.5. inherit

> 定义

规定应该从父元素继承 position 属性的值。

## 3.4. z-index

| 值                 | 描述                                    |
| ------------------ | --------------------------------------- |
| auto               | 默认。堆叠顺序与父元素相等。            |
| number(如-1，2，3) | 设置元素的堆叠顺序。                    |
| inherit            | 规定应该从父元素继承 z-index 属性的值。 |

## 3.5. line-height

> 定义

设置以百分比计的行高：

> 说明

该属性会影响行框的布局。在应用到一个块级元素时，它定义了该元素中基线之间的最小距离而不是最大距离。

> 可能的值

| 值      | 描述                                                 |
| ------- | ---------------------------------------------------- |
| normal  | 默认。设置合理的行间距。                             |
| number  | 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。 |
| length  | 设置固定的行间距。                                   |
| %       | 基于当前字体尺寸的百分比行间距                       |
| inherit | 规定应该从父元素继承 line-height 属性的值。          |

## 3.6. overflow

> 定义

规定当内容溢出元素框时发生的事情。

> 可能的值

| 值      | 描述                                                     |
| ------- | -------------------------------------------------------- |
| visible | 默认值。内容不会被修剪，会呈现在元素框之外。             |
| hidden  | 内容会被修剪，并且其余内容是不可见的。                   |
| scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 |
| auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 |
| inherit | 规定应该从父元素继承 overflow 属性的值。                 |

## 3.7. float

> 浮动的元素只是自身，而不是元素内部的浮动。

## 3.8.justify-content

> 实例

在弹性盒对象的 <div> 元素中的各项周围留有空白：

```css
div
{
    display: flex;
    justify-content: space-around;
}
```

> 定义与用法

justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。

> 属性值

| 值            | 描述                                             |
| ------------- | ------------------------------------------------ |
| flex-start    | 默认值。项目位于容器的开头。                     |
| flex-end      | 项目位于容器的结尾。                             |
| center        | 项目位于容器的中心。                             |
| space-between | 项目位于各行之间留有空白的容器内。               |
| space-around  | 项目位于各行之前、之间、之后都留有空白的容器内。 |
| initial       | 设置该属性为它的默认值。                         |
| inherit       | 从父元素继承该属性。                             |

## 3.9.align-items

> 实例

居中对齐弹性盒的各项 <div> 元素：

`div {     display: flex;     align-items:center; }`

> 定义与用法

align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。

> 属性值

| 值         | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| stretch    | 默认值。元素被拉伸以适应容器。如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。 |
| center     | 元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 |
| flex-start | 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 |
| flex-end   | 元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 |
| baseline   | 元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。 |
| initial    | 设置该属性为它的默认值。                                     |
| inherit    | 从父元素继承该属性。                                         |

# 4． Javascript

## 4.1. 开头

```javasc
<script type="text/javascript">
    var btn1 = document.getElementById('color');
    var btn2 = document.getElementById('content');
    var div = document.getElementsByTagName('div');

    btn1.onclick = function() {
        for(var i=0;i<div.length;i++) {
            div[i].style.display = 'block';
        }
    };

    btn2.onclick = function() {
        for(var i=0;i<div.length;i++) {
            div[i].innerText = 'content';
        }
    };
</script>
```



*a*  : 注意拼写错误；

*b*  : innerText在火狐浏览器中有兼容性问题,低版本的火狐浏览器不支持innerText，指出textContent,textContent在ie6，7,,8中不支持；

*c*  : js改变css样式需要在元素后加style，在加具体样式（如display,color）

## 3.8.width

```css
#header{min-width:100px;}
```

:arrow_forward: min-width:设置元素最小宽度

## 3.9. img

```css
#img{background:url(images/bg.png) no-repeat top center}
```

:arrow_forward: no-repeat:图片不平铺展开，后面的top center产生效果是使图片随页面缩小而随之缩小，展示部分始终是中间部分。

## 3.10.box-shadow

> 作用：box-shadow 属性向框添加一个或多个阴影。

> 属性表

| 值         | 描述                                      |
| ---------- | ----------------------------------------- |
| *h-shadow* | 必需。水平阴影的位置。允许负值。          |
| *v-shadow* | 必需。垂直阴影的位置。允许负值。          |
| *blur*     | 可选。模糊距离。                          |
| *spread*   | 可选。阴影的尺寸。                        |
| *color*    | 可选。阴影的颜色。请参阅 CSS 颜色值。     |
| inset      | 可选。将外部阴影 (outset) 改为内部阴影。> |

示例1

```css
div{box-shadow: 10px 10px 5px #888888;}
```

效果：![1552380660631](E:\typora-document\images\1552380660631.png)

实例2

```css
div{box-shadow: 1px 10px 5px #888888;}
```

效果：![1552380763966](E:\typora-document\images\1552380763966.png)

实例3

```css
div{box-shadow: 10px 1px 5px #888888;}
```

效果：![1552380826847](E:\typora-document\images\1552380826847.png)

实例4

```css
div{box-shadow: 10px 1px 5px #ccc;}
```

效果：![1552380910043](E:\typora-document\images\1552380910043.png)



# 4. oracle

> oracle内部不能使用双引号，必须用单引号

## 4.1.  创建表table

```sql
create table commodity_infom(
        Id  VARCHAR2(50) primary key,/*设置id为主键*/
        cindex integer not null,
        cname VARCHAR2(100) NOT NULL ,
        ckind varchar2(20) not null,
        ckindid varchar2(20) not null,
        ccategory varchar2(100) ,
        cprice number(5,2) not null,
        cstock integer not null,
        cimgurl varchar2(100) not null,
        cdescription varchar2(500),
        utemp1 varchar2(100),
        utemp2 varchar2(100),
        utemp3 varchar2(100)
);
```

### 4.1.1. 设置默认值

```sql
itime date not null default sysdate,--设置系统时间为默认值
ipraise integer default 0,--设置0为默认值
```



## 4.2. 创建序列sequence

```sql
create sequence commodity_infom_tb_seq minvalue 1 maxvalue 9999    
         increment by 1    
         start with 1;
 /*为表commodity_infom建立一个自动增长的序列，名称为commodity_infom_tb_seq，从1开始，最大9999，每次增长1*/
```

> 删除序列

```sql
DROP SEQUENCE commodity_infom_tb_seq  --删除序列
```



## 4.3. 创建触发器trigger

```sql
create or replace trigger commodity_infom_tb_tri
before insert on commodity_infom
for each row
begin
select  commodity_infom_tb_seq.nextval into :new.cindex from dual;
end;
 /*为表commodity_infom建立一个触发器，名称为commodity_infom_tb_tri，每次在表commodity_infom插入一行数据时触发这个触发器，会从序列中commodity_infom_tb_seq找到下一个值放入表commodity_infom的cindex列*/
```

> 删除触发器

```sql
DROP TRIGGER commodity_infom_tb_tri  --删除触发器
```

## 4.4. 创建外键关联

```sql
create table commodity_infod(
        Id  VARCHAR2(50) primary key ,
        cmainid varchar2(50) not null references commodity_infom(id),
    	cpicture varchar2(100) not null,
        utemp1 varchar2(100),
        utemp2 varchar2(100),
        utemp3 varchar2(100)
);
/*将cmainid设置为主表commodity_infom的外键，用主表id进行关联*/
```

## 4.5. 修改列名与类型

```sql
alter table commodity_newsm rename column  cimgurl to  iimgurl;--修改列名
alter table 表名 modify (列名varchar(255));--修改列类型
--修改列类型也可以通过编辑表的列名和类型修改
alter table  表名  drop column 列名; --删除一列
alter table 表名  add 列名   类型   default   值 < not null>; --增加一列
```

## 4.6. 添加唯一约束

```sql
alter table user_infom
add constraint user_infom_name_unique unique(uname);
--为表user_infom的uname列添加唯一约束，名称为user_infom_name_unique
```

## 4.7. 添加外键约束

```sql
--普通外键约束（如果存在子表引用父表主键，则无法删除父表记录）
ALTER TABLE commodity_newsd ADD CONSTRAINT commodity_newsd_foreign_key FOREIGN KEY(imainid) REFERENCES commodity_newsm(id);
--级联外键约束（可删除存在引用的父表记录，而且同时把所有有引用的子表记录也删除）
ALTER TABLE commodity_newsd ADD CONSTRAINT commodity_newsd_foreign_key FOREIGN KEY(imainid) REFERENCES commodity_newsm(id) ON DELETE CASCADE;
--置空外键约束（可删除存在引用的父表记录，同时将子表中引用该父表主键的外键字段自动设为NULL，但该字段应
--允许空值）
ALTER TABLE commodity_newsd ADD CONSTRAINT commodity_newsd_foreign_key FOREIGN KEY(imainid) REFERENCES commodity_newsm(id) ON DELETE SET NULL;
```

## 4.8. java连接oracle

```java
private static String driver = "oracle.jdbc.driver.OracleDriver";
private static String url="jdbc:oracle:thin:@127.0.0.1:1521:orcl";
private static String username="websjkknow";
private static String password="websjkknow";
```

# 5.Git

## 5.1. 初始化本地库

git init:初始化一个Git仓库；

![1551873642007](E:\typora-document\images\1551873642007.png)

ll .git/:查看隐藏文件内部文件；

![1551873839648](E:\typora-document\images\1551873839648.png)

上方目录即为刚初始化的git仓库。

## 5.2.查看资源

ll:将当前路径下的资源详情进行罗列；

![1551872356867](E:\typora-document\images\1551872356867.png)

ls -lA:将当前路径下所有资源（包含隐藏资源）全部罗列出来；

![1551872570026](E:\typora-document\images\1551872570026.png)

ls -s|less:分屏查看上述罗列的资源（可以按Ctrl+z退出）；

cd  一个路径：进入这个路径；

![1551873080816](E:\typora-document\images\1551873080816.png)

mkdir WeChat:在当前目录下创建一个名为WeChat的文件夹；

![1551873439290](E:\typora-document\images\1551873439290.png)

ls lA|less:分屏罗列所有资源（包含隐藏资源）

![1551939435305](E:\typora-document\images\1551939435305.png)

pwd:查看当前路径

![1555901276942](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1555901276942.png)

## 5.3. 设置签名

*☆*  形式：

​	→ 用户名：tom

​	→ Email地址：goodmorning@163.com

:cry:  作用：区分开发人员身份

:arrow_forward: 辨析：这里设置的签名与登录远程库的账号（代码托管中心）的账号、密码没有任何关系

:anchor: 命令：

​	:balloon:  项目级别/仓库级别：仅仅在本地库范围有效

​		◇ git config user.name jojo

​		◇ git config user.email jojo@163.com

​		◇ 数据存储位置：git内部的config文件

![1551938837933](E:\typora-document\images\1551938837933.png)

​	:balloon: 系统用户级别：登录当前操作系统的用户范围

​		◇ git config --global user.name admin

​		◇ git config --global user.email admin@163.com

​		◇ 数据存放位置：~/.gitconfig

![1551939564133](E:\typora-document\images\1551939564133.png)

​	:diamonds:  优先级：

​		◇ 就近原则：项目级别优先于系统用户级别

​		◇ 二者都没有是不被允许的

## 5.4.文件提交流程

> git开头的命令都是git自有的，与Linux不互通

:arrow_forward: git status：查看工作区、暂存区状态

:arrow_forward: vim good.txt:如果不存在，则创建一个名为good.txt的文件；如果已经存在，则进入编辑模式

创建文件后，会进入文件内部：

![1551941992581](E:\typora-document\images\1551941992581.png)

按i进入编辑模式

按Esc切换命令行模式，退出文件命令是:wq

此时再次键入git status命令会显示有新文件出现，提示可通过git add filename提交该文件

:arrow_forward: git add good.txt：提交文件进入暂存区

:arrow_forward: git rm --cached good.txt：将文件从暂存区删除

:arrow_forward: git commit:将文件从暂存区提交到本地库

:arrow_forward: git commit  -m "this is a log":将文件从暂存区提交到本地库，同时提交日志

commit后会进入一个vim编辑器界面，编辑一些关于此次修改的消息（注释或目的等）。

按esc从编辑模式切换到命令行后，写入命令:set nu，回车，可显示行号。同样用:wq退出。

![1551943272725](E:\typora-document\images\1551943272725.png)

## 5.5.本地库历史版本

:arrow_forward: cat good.txt:查看文件内容

:arrow_forward: git commit  -m "My second commited file is success!" good.txt:新加的-m可以直接编辑此次修改的消息，不需要进入vim编辑器模式

:arrow_forward: git log:查看git本地库的历史版本

:arrow_forward: git log --pretty=oneline:以一行显示一个历史版本

:arrow_forward: git log --oneline:以一行显示一个历史版本

:arrow_forward: git reflog:用一行显示一条历史记录，并显示从当前版本转移到另一个版本时需要转移的次数。

（HEAD@{1}表明需要转移一次）

以上四条命令结果如下图：

![1551945691939](E:\typora-document\images\1551945691939.png)

:arrow_forward: 多屏控制方式：空格向下翻页，按b向上翻页，按q退出

:arrow_forward: git reset --hard 版本号：通过基于索引值的方式，将版本返回到过去或未来的某个版本

![1551947157664](E:\typora-document\images\1551947157664.png)

![1551947515830](E:\typora-document\images\1551947515830.png)

 :arrow_forward: git reset --hard HEAD^^：通过控制^的数量将版本返回过去的某个版本。返回后通过git log --oneline的方式将不能在查看未来的版本历史记录。

![1551948162498](E:\typora-document\images\1551948162498.png)

:arrow_forward: git reset --hard HEAD~1:通过控制波浪线后的数字来控制返回到过去的某个版本。

![1551948474125](E:\typora-document\images\1551948474125.png)

:arrow_forward: reset/Ctrl+L：清屏

:arrow_forward: reset 的三个参数详解：reset实质上就是控制HEAD指针指向不同的历史版本

​	☆  soft:	 在本地库修改指针，

​	☆  mixed:在本地库修改指针，重置暂存区

​	☆  hard:  在本地库修改指针，重置暂存区、工作区（本地文件）

:arrow_forward: rm god.txt:删除一个文件

前提：删除文件前已将文件提交到本地库。将文件删除删除后，需将删除的文件提交到暂存区，此时可通过git reset --hard HEAD将工作区与暂存区进行重置，文件将会恢复到未删除的状态。通过git reset HEAD将暂存区进行重置，文件将恢复到刚删除还未提交状态。

## 5.6.比较版本差异

> HEAD表示指针，表示指针指向某个历史版本

:arrow_forward:  git diff  文件名：比较文件内容与暂存区中内容差异

:arrow_forward: git diff HEAD^ 文件名:将文件与某个历史版本进行比较

![1552011563480](E:\typora-document\images\1552011563480.png)

## 5.7.分支操作

:black_flag: git branch -v:查看各个分支

:black_flag: git branch 分支名：创建一个分支

![1552013385911](E:\typora-document\images\1552013385911.png)

:black_flag: git checkout 分支名：切换分支

![1552013526328](E:\typora-document\images\1552013526328.png)

:black_flag: git merge 分支名：合并分支

合并分支操作流程：首先需要切换到接收有新内容分支的分支--git checkout 负责接收的分支的名字，然后是这个分支接收有新内容分支--git merge 有新内容分支的名字。

![1552014492435](E:\typora-document\images\1552014492435.png)

合并分支时，如果遇到冲突，会这样被标记出来：

![1552016089154](E:\typora-document\images\1552016089154.png)

可在命令行时，在鼠标所在行敲d即可删除当前行。将内容修改完成后即可退出。通过git add 文件名，将冲突解决。但是此时合并未结束，需要提交到本地库才可以。通过git commit -m "修改消息或提示"即可结束合并。命令最后不可加入文件名。

![1552016619703](E:\typora-document\images\1552016619703.png)

## 5.8.向github推送和拉取

:black_flag: git remote -v:查看github地址

:black_flag: git remote add origin https://github.com/mikasamikodu/WeChat.git:向本地库添加一个推送地址https://github.com/mikasamikodu/WeChat.git，并起别名为origin。以后本地库可以向这个github地址进行推送和拉取数据。

![1552030425593](E:\typora-document\images\1552030425593.png)

:black_flag: git push origin master:将master分支推送到origin地址

![1552031292559](E:\typora-document\images\1552031292559.png)

:black_flag: git clone github项目地址:将github上的项目克隆到本地的仓库

![1552031837564](E:\typora-document\images\1552031837564.png)

克隆有三个效果：

​	a.完美地把远程库下载到本地；

​	b.创建origin远程地址别名；

​	c.初始化本地库；

:black_flag: git push origin master:向origin地址发送master分支内容

第一次push可能不会成功，因为没有向项目里推送的权限。需要对方先邀请你加入团队然后才可以推送数据。

邀请方式：点击标记处的settings

![1552035095384](E:\typora-document\images\1552035095384.png)

然后进入另一个地方：

![1552035176522](E:\typora-document\images\1552035176522.png)

点击左侧的collabortors，在右侧的搜索框填写需要邀请的账号，出现后点击搜索框右侧的按钮即可。会发送一封邮件到对方的注册邮箱中。

:black_flag: git fetch 地址别名 分支名:从远程库上抓取数据

:black_flag: git merge 地址别名/分支名:合并数据

:black_flag: git checkout 地址别名 分支名:切换路径，查看从远程库上抓取下来的数据

要点：如果不是github远程库上最新版所做的修改，不能推送，必须先拉取。拉取后如果产生冲突，则按照“分支冲突”解决即可。

## 5.9.生成SSH密匙

1.进入当前用户的家目录：$cd~

2.删除.ssh目录：$rm -r .ssh/

3.运用命令生成.ssh密匙目录:$ssh-keygen -t rsa -C 登录github的邮箱名，中间需要设定一些东西，只需要回车就可以。

4.进入.ssh目录:cd .ssh/

5.查看内部文件：$ll

6.查看文件：$cat id_rsa.pub，将文件内容复制，打开github个人设置-SSH and GPG keys。点击SSH keys的右上角new ssh key,将复制的内容放入key的文本域。在title部分编写一个标题（如mykey）即可。

7.进入工作区测试：cd 工作区地址，并修改工作区文件并提交。

8.在本地添加一个github的ssh地址：$ git remote add origin_ssh github上ssh地址名

9.查看地址：$git remote -v,然后推送数据,此时还需要确认一次是否推送，写入yes回车即可，最后显示成功。

## 5.10.加入.gitignore文件

项目中有许多不需要放入代码仓库的文件，可以通过.gitignore来忽略这些文件。

1.首先找到.gitconfig（C:/User/Administrator/.gitconfig），然后在这里建立一个java.gitignore文件(名称随便，后缀固定)，在里面加入如下内容：

```
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
.classpath
.project
.setting
target
```



2.将java.gitignore的文件路径加入.gitconfig文件

打开.gitconfig文件，新建一个[core]，在下面加入如下路径：

excludesfile = C:/User/Administrator/java..gitignore。路径要用/连接，不能用\。

完成后可在eclipse中查看，路径window>preferences>team>git>configration>user settings。

## 5.11.通过eclipse使用git

### 5.11.1初始化本地库

在工程名上右击>team>share project>git>勾选左上角的单选框，如下：

![1552356505435](E:\typora-document\images\1552356505435.png)

勾选后，页面会变化，如下：

![1552356578010](E:\typora-document\images\1552356578010.png)

点击工程，下方的create Repository会由不可编辑变为可编辑状态，若编辑路径，可改变这个工程git本地库的位置。勾选工程，点击create按钮，然后点击finish即可将工程加入本地库。

### 5.11.2.设置签名

在菜单栏中，找到window，然后window>preferences>team>git>configuration如下：

![1552357017102](E:\typora-document\images\1552357017102.png)

在右侧界面选择user settings中,location位置不可编辑，是全局的gitconfig文件，负责管理本地所有git本地库。点击右侧的Add Entry...可以在key-value中添加数据，编辑gitconfig的配置文件。添加键值对如下：

![1552357287579](E:\typora-document\images\1552357287579.png)

全部完成后，点击apply即可完成设置。在repository setting中可以查看已经添加到git的工程的配置。

### 5.11.3.添加.gitignore文件

参考5.10

### 5.11.4.add and commit

首先修改文件，文件将会变化，如下：

![1552357744301](E:\typora-document\images\1552357744301.png)



然后在此文件上右击>team>add to index，此时文件将会被加入暂存区。

也可以直接commit，同样右击>team>commit，如下：

![1552357877562](E:\typora-document\images\1552357877562.png)

unstaged changes区是修改后未加入暂存区的文件，staged changes区是修改后已加入暂存区的文件，

commit message指的是修改的日志，最后点击右下角的commit,即可将修改提交到本地库。

### 5.11.5.push

右击项目>team>remote>push，结果如下：

![1552358152220](E:\typora-document\images\1552358152220.png)

此时需要将远程库的地址加入URI的文本框（确保远程库上已有这个项目的远程库），hosts与repository path，将会根据uri自动填充。然后在user和password中写上远程库的用户名与密码，并勾选左下角的store in secure store，可以在本地存储远程库的用户名与密码。点击next，如下：

![1552358649740](E:\typora-document\images\1552358649740.png)

点击途中红框处的add add branches spec，课件给所有分支选中添加到下方的框中，点击next,可编辑修改日志，如下：

![1552358781933](E:\typora-document\images\1552358781933.png)

也可以直接点击finish完成推送（中间会有几秒等待时间才会返回结果，点击close关闭结果界面即可）。

### 5.11.6.克隆

在左侧项目处右击>import>git>projects from git>clone uri，结果如下：

![1552359607103](E:\typora-document\images\1552359607103.png)

操作同上，将远程库地址复制放入uri中，填写user and passowrd，勾选store in secure store，点击next,选择需要clone的分支，点击next，选择本地库放置位置（最好选择eclipse的项目放置位置，方便eclipse管理），加入工程名称，点击确定，点击next，结果如下：

![1552360239841](E:\typora-document\images\1552360239841.png)

这是要求选择向eclipse导入项目的方式，选第三个import as general project，点击next，点击finish即可。

此时目录结构松散难以使用，点击右键>configure>convert to meven project即可。此方法只适用于meven工程。

### 5.11.7.解决冲突

同时修改同一项目的2个本地库，将其中一个修改提交，并推送到远程库，另一项目推送会失败：

![1552361706285](E:\typora-document\images\1552361706285.png)

此时，需要先拉取下来远程库资源，解决冲突在推送。先拉取内容，	点击右键>team>

第二个pull，将远程库的地址放入uri中，填写user和pasword，用远程库的用户名与密码，勾选左下角的框。

产生冲突时，如下：

![1552362149178](E:\typora-document\images\1552362149178.png)

可通过右击>team>merge pool,结果如下：

![1552370845074](E:\typora-document\images\1552370845074.png)

对比两侧内容，左侧可以修改，右侧不可修改，修改左侧内容。将内容修改完毕，进行提交，最后push到远程库即可。

### 5.11.8.管理分支

首先创建分支，右键>team>new branch，填写新分支名称，点击finish即可。之后可以正常提交并推送分支。

可以通过右键>team>switch to>master切换分支。

如果远程库上有分支，但是本地库没有，则需要如此做：

首先切换到主分支，然后右键>team>switch to>other,结果如下：

![1552372175314](E:\typora-document\images\1552372175314.png)

点击remote tracking,将本地库没有的分支选中，点击下方的check out,然后选择如下：

![1552372253798](E:\typora-document\images\1552372253798.png)

点击即可。

# 6.struts02

## 6.1.搭建环境

### 6.1.1.加入jar包

（在路径：E:\jar\struts-2.3.20.3\lib\lib下面）

![1554087491344](E:\typora-document\images\1554087491344.png)

### 6.1.2.编写struts.xml文件

在类路径的顶层目录下，编写struts.xml文件

![1554087555343](E:\typora-document\images\1554087555343.png)

如果处于无网络环境，该文件可能产生警告。解决办法：

a. 在struts文件夹中找到lib下的一个jar包struts2-core-2.3.20.3.jar，然后进行解压缩，只需从里面去取出一个dtd文件struts-2.3.dtd即可；

b. 在WEB_INF目录下新建一个文件夹dtd，然后将dtd文件放入；

c. 在myeclipse的菜单栏中进入Window>preferences，然后搜索找到XML Catalog。

d. 点击右侧的Add；

![1554087670310](E:\typora-document\images\1554087670310.png)

e. 在location位置添加dtd的地址（只需点击下方的Workspace选择路径即可），然后将KeyType选为URI，在Key中填入http://struts.apache.org/dtds/struts-2.3.dtd即可。

### 6.1.3.编写struts的控制器

在web.xml中，编写struts的控制器

![1554087801404](E:\typora-document\images\1554087801404.png)

## 6.2.入门案例

### 6.2.1.编写struts.xml

开发阶段需要配置`struts.devMode` ,可以在修改代码后无需重启即可生效。package标签需继承struts-default才可以

![1554087931915](E:\typora-document\images\1554087931915.png)

### 6.2.2.编写类

动作类需要继承ActionSupport类

![1554088008117](E:\typora-document\images\1554088008117.png)

### 6.2.3.编写相关JSP

过滤器会拦截所有以.action结尾或无后缀的请求，如demo.action和demo

![1554088052493](E:\typora-document\images\1554088052493.png)

两个连接都跳转成功了。

## 6.3.入门案例内部执行过程

### 6.3.1.加载web.xml

Web应用启动tomcat时,会首先加载web.xml，检查内部servlet，filfter,listener路径是否正确，名称是否对应。

### 6.3.2.加载过滤器

加载web.xml时会同时初始化并实例化过滤器（实际上就是为了加载struts的过滤器，拦截所有访问动作的请求）。

### 6.3.3.加载struts.xml

初始化过滤器后，会继续加载struts.xml文件，建立动作与类之间的映射。

### 6.3.4.发送hello.action请求

在用户点击首页链接时，会向tomcat发送访问hello.action的请求。

### 6.3.5.拦截请求

当请求到达tomcat时，过滤器会拦截请求，并在struts.xml中查找相关动作。

### 6.3.6.实例化动作类

在struts.xml中查找到相应的类后进行实例化（每次找到都会创建一个新的实例），然后进行调用相应动作类，结果会产生返回值。

### 6.3.7.调动相关JSP

根据返回值在struts.xml中找到相应的视图页面进行调用，并向浏览器返回结果。

## 6.4.动作方法调用配置

### 6.4.1.自动布置

在struts.xml开始部分，与package标签同级，在struts开始标签内部

`<constant name="struts.devMode" value="true"></constant>`

### 6.4.2.动态方法调用

在struts.xml开始部分，与package标签同级，在struts开始标签内部

`<constant name="struts.enable.DynamicMethodInvocation" value="true"></constant>` 

### 6.4.3.使用通配符*

使用通配符*，配置动作方法 

*表示的是动作名称，当有和动作名称相匹配的时候可以用{出现的位置}来代替

a.

struts.xml:

```xml
<action name="*" class="com.itheima.web.action.UserAction" method="{1}">
	<result name="success">/{1}.jsp</result>
</action>
```

index.jsp:

```jsp
<a href="${pageContext.request.contextPath }/addUser.action">添加用户</a><br/>
<a href="${pageContext.request.contextPath }/updateUser.action">更新用户</a><br/>
<a href="${pageContext.request.contextPath }/deletUser.action">删除用户</a><br/>
<a href="${pageContext.request.contextPath }/findUser.action">查找用户</a><br/>
```

b.

struts.xml:

```xml
<action name="*_*" class="com.itheima.web.action.{2}Action" method="{1}{2}">
	<result name="success">/{1}{2}.jsp</result>
</action>
```

index.jsp:

```jsp
<a href="${pageContext.request.contextPath }/add_User.action">添加用户</a><br/>
<a href="${pageContext.request.contextPath }/update_User.action">更新用户</a><br/>
<a href="${pageContext.request.contextPath }/delete_User.action">删除用户</a><br/>
<a href="${pageContext.request.contextPath }/find_User.action">查找用户</a><br/>
```

​	

### 6.4.4.继承ActionSupport类

动作类需继承ActionSupport类，默认动作类会变为ActionSupport，默认方法是execute。

## 6.5.分文件编写配置文件

这样做的原因：

1、首先需要在struts.xml同一包中编写动作相关方法。当系统模块变多时，不同模块的动作在一个包会混杂在一起。

2、此时可以通过将不同模块的动作分包（package）而放来解决这种混乱的局面。

3、一个人编辑同一个文件时虽然不会混乱，但是当多人编写同一个配置文件时会变得混乱。所以可以采取分文件编写配置文件。

 ## 6.6.封装参数

### 6.6.1.静态封装

将参数以注入的方式封装在动作中，如图：

![1552552309970](E:\typora-document\images\1552552309970.png)

### 6.6.2.动态封装参数1

动作类正常配置，动作方法中同时封装了实体类的属性。动作方法如图：

![1552552502120](E:\typora-document\images\1552552502120.png)

​	动作类如图：

![1552552537812](E:\typora-document\images\1552552537812.png)

### 6.6.3.动态封装参数2

动作类正常配置，动作方法中将不再保留实体类的属性而是引入实体类。动作方法如图：

![1552552771630](E:\typora-document\images\1552552771630.png)

同时，JSP中需要改变，如图：

![1552552890258](E:\typora-document\images\1552552890258.png)

### 6.6.4.模型驱动

动作类正常配置，jsp同样正常配置，其他变化如下：

实现步骤：
​	 1.实现ModelDriven<T>接口

​	2.实现接口需要实现的方法

​	3.使用模型驱动方式时，必须自己将数据模型实例化

![1552553085143](E:\typora-document\images\1552553085143.png)

jsp配置如下：

![1552553256565](E:\typora-document\images\1552553256565.png)



## 6.7.类型转换器

举例：将日期类型格式由yyyy-mm-dd转换为mm/dd/yyyy

### 6.7.1.创建转换类

要求必须创建一个类并继承StrutsTypeConverter，代码如下：

```java
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;

import org.apache.struts2.util.StrutsTypeConverter;

public class MyTypeConvert extends StrutsTypeConverter {
	
	private DateFormat format = new SimpleDateFormat("MM/dd/yyyy");
	/**日期数据转换器
	 * 参数解读：
	 * 	arg1:需要转换的参数
	 * 	arg2:目标类型
	 */

	@SuppressWarnings("rawtypes")
	@Override
	public Object convertFromString(Map arg0, String[] arg1, Class arg2) {
		//1. 检查arg1是否为空
		if(arg1 == null||arg1.length == 0){
			return null;
		}
		//2. 取出arg1的第一个参数
		String value = arg1[0];
		//3. 检查arg2的字节码是否是日期类型
		if(arg2 == java.util.Date.class){
		//4. 转换并返回结果
			try {
				return format.parse(value);
			} catch (ParseException e) {
				e.printStackTrace();
				return null;
			}
		}
		return null;
	}

	@SuppressWarnings("rawtypes")
	@Override
	public String convertToString(Map arg0, Object arg1) {
		//1. 首先判断arg1是否是日期类型
		if(arg1 instanceof Date){
		//2. 是则将其转换成指定的格式并返回
			Date date = (Date) arg1;
			return format.format(date);
		}
		return null;
	}

}
```



### 6.7.2.配置类型转换器

​	关于类型转换器的配置有两种方法，一种局部的，一种全局的。

1.局部的配置

在javabean类同路径下建立javabean类名-conversion.properties文件，内部内容如下：

```properties
birthday=com.itheima.utils.MyTypeConvert
```

2.全局的配置

在src路径下建立固定名称的xwork-conversion.properties文件，内容是：

```properties
java.util.Date=com.itheima.utils.MyTypeConvert
```

3.类型转换失败后的处理

​	类型转换失败后，转换视图是有conversionError拦截器控制的,因此动作类需要继承ActionSupport类。

​	当表单数据格式错误时，需要让页面回到原来的页面而不是跳转到一个系统出错的页面。此时可以在struts.xml配置一下用户输入信息格式有误时的结果。

```xml
<result name='input'>/register/jsp</result>
```

​	然后在表单页面添加如下代码，多了页面红框里面的提示:

![1553847690319](E:\typora-document\images\1553847690319.png)

页面变化：![1553847750857](E:\typora-document\images\1553847750857.png)



​	jsp部分除了上面这种处理办法，还有另外一种。就是使用struts特有的标签：

![1553848712468](E:\typora-document\images\1553848712468.png)

页面：

![1553848742791](E:\typora-document\images\1553848742791.png)

关于中文，还需要在javabean下添加一个以javabean名称命名的properties文件，内容：

```properties
invalid.fieldvalue.birthday=\u751F\u65E5\u683C\u5F0F\u65E0\u6548\uFF0C\u683C\u5F0F\uFF1Ayyyy-MM-dd
```



Invalid field value for field "birthday"》invalid.fieldvalue.birthday

## 6.8.数据验证

### 6.8.1编程式验证

​	在struts02中可以通过在动作类中：:one: 实现ActionSupport;:two: 重写validate方法来实现数据验证。

```java
public void validate(){
    if(StringUtils.isBlank(user.getUsername()))
        //使用commons-lang3.jar中的StringUtil方法的isEmpty进行字段的非空校验（不去字段内空格）
        //使用isBlank()同样可以（去除字段内空格）
        addFieldError("username", "请输入用户名！");
}
```

​	这种方法会在这个动作执行之前，进行数据验证。

​	要想实现让单个方法不进行数据验证可以在方法上方加注解`@SkipValidation`；如果只想让某个方法进行验证也可以是validate+动作名称即可(命名采用驼峰命名)，如validateRegister()。（动作名称指的是struts.xml中action的name属性）

![1556075241554](E:\typora-document\images\1556075241554.png)

### 6.8.2.声明式验证

:one:	全局的数据验证

在src路径下配置ActionClassName-validation.xml文件，内容格式如下：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE validators PUBLIC
	"-//Apache Struts//XWork Validator 1.0.3//EN"
	"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validation>
<!-- 基于字段的验证 -->
	<field name="username">
	<!-- field中name指定的是表单中name属性取值 -->
		<field-validator type="requiredstring">
		<!-- struts2中有许多内置验证器，requiredstring会验证输入内容是否为空，是否为空字符串，并且去除左右空格。-->
			<message>请输入用户名</message>
		</field-validator>
	</field>
    
    <!-- 基于验证器的验证 -->
	<validator type="requiredstring">
	<!-- 以注入的方式提供要验证的字段信息，setFieldName("password") -->
		<param name="fieldName">password</param>
		<message>请输入密码</message>
	</validator>
</validation>
```



名称实例：为UserAction这个动作类建立xml文件，名称为UserAction-validation.xml。

这个文件验证的是全局的。可以通过注解`@SkipValidation`让某些方法不进行验证。

:two:  局部的数据验证

在动作类所在包下建立xml文件，格式是动作类名称-动作名称-validation.xml（动作名称是指struts.xml中action的name属性），内容与上面相同。

 :three: 数据验证失败

1.检查validation文件名是否符合规则；

2.检查每个需要验证的字段的name是否与jsp页面的字段的name相等，顺便检查每个标签是否都是开标签和比标签对应，如果有不对应的，开发工具能不会给出提示; 

3.检查xml文件开头的struts的引用是否正确，不同版本struts的引用会有所不同；

struts的引用：

```xml
<!DOCTYPE validators PUBLIC
	"-//Apache Struts//XWork Validator 1.0.3//EN"
	"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
```



4.检查struts.xml中结果处理中是否有对input结果的处理；

5.检查实体类与动作类名称是否相符（如User与UserAction）;

6.检查动作类是否实现了ActionSupport；

7.如果采用了模型驱动的方式，检查是否有实现了`ModelDriven<T>` 的接口；

 :four: 案例

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE validators PUBLIC
	"-//Apache Struts//XWork Validator 1.0.3//EN"
	"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validators>
	<!-- 基于字段的验证 -->
	<field name="username">
		<!-- field中name指定的是表单中name属性取值 -->
		<field-validator type="requiredstring">
			<!-- struts2中有许多内置验证器，requiredstring会验证输入内容是否为空，是否为空字符串，并且去除左右空格。 -->
			<message>请输入用户名</message>
		</field-validator>
	</field>

	<field name="age">
		<field-validator type="int">
			<!-- 使用注入方式，设置最大值和最小值 -->
			<param name="min">18</param>
			<param name="max">100</param>
			<message>请输入18到100之间整数</message>
		</field-validator>
	</field>

	<field name="email">
		<field-validator type="email">
			<message>请输入正确的邮箱格式</message>
		</field-validator>
	</field>

	<field name="password">
		<field-validator type="requiredstring">
			<!-- 注入取消trim -->
			<param name="trim">false</param>
			<message>请输入密码</message>
		</field-validator>
		<field-validator type="requiredstring">
			<param name="minLength">3</param>
			<param name="maxLength">8</param>
			<message>请输入3到8位密码</message>
		</field-validator>
	</field>

	<!-- 确认密码与密码需保持一致，是2个字段的事，所以要使用基于验证器的方式 -->
	<validator type="expression">
		<param name="expression">
			<![CDATA[password==repassword]]>
		</param>
		<message>两次密码必须一致</message>
	</validator>

	<field name="score">
		<field-validator type="regex">
			<param name="regex">
				\d+
			</param>
			<message>请输入正确的成绩</message>
		</field-validator>
	</field>

	<field name="url">
		<field-validator type="url">
			<message>请输入正确格式的url</message>
		</field-validator>
	</field>

	<field name="gender">
		<!-- 只验证是否为null，不会去空格 -->
		<field-validator type="required">
			<message>请选择性别</message>
		</field-validator>
	</field>
</validators>
```



## 6.9.国际化i18n

### 6.9.1.r18n

1.编写配置文件

​	文件名称规则：`主文件名称_语言代码_国家代码.properties` ，名称没有规则，随意编写，如message，语言编码和国家代码需要自己搜索，通过百度或jdk手册查询，文件至少编辑2个。例如中国的和美国的，文件放置位置无规定；

![1556174992525](E:\typora-document\images\1556174992525.png)

2.读取配置文件

在测试类中通过类ResourceBundle的getBundle("文件所在包.主文件名称",Locale.国家常量)方法读取配置文件，在通过getString("key的name")。

![1556175183348](E:\typora-document\images\1556175183348.png)

3.在jsp页面配置

首先加载文件，在jsp文件开头部分：

```jsp
<%
Locale locale = request.getLocale();
ResourceBundle resource = ResourceBundle.getBundle("com.itheima.resource.message", locale);
 %>
```

然后将中文名成标签等需要国际化部分进行替换。

```jsp
  <head>
    <title><%=resource.getString("jsp.register.title") %></title>
  </head>
  <body>
   	<%=resource.getString("jsp.register.username") %>:<input type="text" name="username"/><br/>
   	<%=resource.getString("jsp.register.password") %>:<input type="password" name="password"/><br/>
   	<input type="submit" value="<%=resource.getString("jsp.register.button")%>"/>
  </body>
```

### 6.9.2.struts2中国际化

1.全局范围配置

在单独的package中添加消息资源包，可以设置为全局范围的。（消息资源包就用上方编写的就可以）

使用方式是首先在struts.xml中进行配置，在`<struts>`标签下添加：

```xml
<constant name="struts.custom.i18n.resources" value="com.itheima.resource.message"/>
```

在动作方法中可以通过`getText("key")` 获取消息资源包中的key值。

2.包范围配置

将消息资源包放在全局范围配置所在包的上一级包中时，不需要其他配置即可成为优先级高于全局配置的包范围配置。（消息资源包就用上方编写的就可以）

3.动作类范围

将消息资源包放在动作类所在包下面，资源包主文件名称需要改成动作类名。（消息资源包就用上方编写的就可以）

资源包位置配置如图：

![1556179280685](E:\typora-document\images\1556179280685.png)

4.资源包查找顺序

struts获取配置使用的是就近原则。如果直接在页面上访问消息资源包则不会经过struts的action，不会触发类范围的和包范围的消息资源包，只会触发配置过的全局的消息资源包。而如果经过action则需要采取就近原则，有限使用动作类范围的。

5.在jsp中访问资源包

```jsp
<s:text name="key"></s:text>
```

如果资源包中不存在名为key的key，则会直接将key作为内容输出。

也可以在经过动作类时自由指定资源包位置：

```jsp
<s:i18n name="com.itheima.resource.message">
	<s:text name="key"></s:text>
</s:i18n>
```



当自由指定的包不存在时，会按照资源包的搜索顺序查找。如下：

![1556180174317](E:\typora-document\images\1556180174317.png)

## 6.10.自定义拦截器

定义方法：

​	1.定义一个类，并且这个类要继承AbstractInterceptor这个类；

```java
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;
public class Interapter1 extends AbstractInterceptor {
	public String intercept(ActionInvocation arg0) throws Exception {
		System.out.println("interapter1执行了");
		return null;
	}
}
```



​	2.在struts.xml需要使用这个拦截器的package中，声明这个拦截器，并在action中使用这个拦截器;

```xml
<package name="p1" extends="struts-default">
		<interceptors>
		<!-- 声明拦截器 -->
		</interceptors>
		<action name="save" class="com.itheima.web.action.Action1" method="save">
			<interceptor-ref name="demo1"></interceptor-ref>
			<!-- 使用拦截器 -->
			<result>/demo1.jsp</result>
		</action>
	</package>
```

​	3.在拦截后处理完数据就可以放行(放行语句：arg0.invoke())了，拦截器执行完需要返回结果视图（input,success等）；

```java
public String intercept(ActionInvocation arg0) throws Exception {
		System.out.println("interapter1执行了");
		String result = arg0.invoke();
		System.out.println("interapter放行了");
		return result;
	}
```

​	

拦截器在动作执行前，会进行拦截处理数据。然后放行执行动作。执行完动作，会再次经过拦截器处理数据。

如果有多个拦截器，如1,2,3，拦截器执行顺序为1，2，3，动作，页面，3，2，1，前面的1,2,3执行循序是由在action中配置的拦截器使用顺序决定的。

​	4.配置包内全局的结果视图

​	在package标签内部，

```xml
<global-results>
			<result name="input">/login.jsp</result>
</global-results>
```



​	全局的结果视图作用是当某个动作没有配置该视图时，会在全局的结果视图里搜索该视图，搜索到就使用。

​	5.配置自己的拦截器栈

```xml
<package name="p2" extends="struts-default">
    <interceptors>
        <interceptor name="checklogin" class="com.itheima.web.interapter.CheckLoginInterapter"></interceptor>
        <!--声明拦截器-->
        <interceptor-stack name="myDefaultStack">
            <!--配置拦截器栈-->
            <interceptor-ref name="defaultStack"></interceptor-ref>
            <interceptor-ref name="checklogin"></interceptor-ref>
        </interceptor-stack>
    </interceptors>
    <action name="showMain" class="com.itheima.web.action.Action2">
        <interceptor-ref name="myDefaultStack"></interceptor-ref>
        <!--使用拦截器栈-->
        <result>/main.jsp</result>
    </action>
	</package>
```



6.配置默认的拦截器使用栈后，会覆盖struts原来默认的。

在package标签内配置如下：

```xml
<default-interceptor-ref name="myDefaultStack"></default-interceptor-ref>
```



这样需要使用默认拦截器使用栈的动作就不需要自己另外配置拦截器了。

但是这样的设置会导致所有的动作都相当于配置了这个拦截器使用栈。可以通过在拦截器栈内的拦截器声明中配置参数excludeMethods或includeMethods来控制哪些动作需要被拦截，哪些不需被拦截。includeMethods控制需要拦截的动作，excludeMethods控制不需要拦截的动作。两者可以只配置一种。配置这两个参数时，有个前提，就是动作需要继承MethodFilterInterceptor这个类，这个类也继承自AbstractInterceptor。这个类的子类必须实现的方法是doIntercept。

```xml
<interceptors>
    <interceptor name="checklogin2" class="com.itheima.web.interapter.CheckLoginInterapter2"></interceptor>
    <interceptor-stack name="myDefaultStack">
        <interceptor-ref name="defaultStack"></interceptor-ref>
        <interceptor-ref name="checklogin2">
            <!--不拦截login动作-->
            <param name="excludeMethods">login</param>
        </interceptor-ref>
    </interceptor-stack>
</interceptors>
```



拦截器与动作：先有拦截器，后有动作，因此不能在拦截器中配置参数excludeMethods，includeMethods。所以我们需要在动作内进行声明。

```xml
<action name="login" class="com.itheima.web.action.Action2" method="login">
    <interceptor-ref name="myDefaultStack">
        <param name="checklogin2.excludeMethods">login</param>
    </interceptor-ref>
    <result type="redirectAction">showMain</result>
</action>
```



## 6.11.文件上传下载

### 6.11.1文件上传

1.form表单的要求；

​	a.请求方式method必须是post;

​	b.enctype属性取值必须是multipart/form-data；

​	c.提供一个文件上传域file；

2.配置struts.xml；

3.编写动作；

```java
//表单提供的字段
private String username;
private File file;
private String fileFileName;//上传的文件名，上传字段名称+FileName 注意大小写
private String fileContentType;//上传文件的MIME类型，上传字段名称+ContentType,注意大小写
public String upload(){
    //1.拿到ServletContext
    ServletContext servlet = ServletActionContext.getServletContext();
    //2.调用realPath,根据一个虚拟目录路径获得其内部的一个真实目录路径
    String filePath = servlet.getRealPath("/WEB-INF/files");
    File file1 = new File(filePath);
    //3.检查目录是否存在，如果不存在就创建
    if(!file1.exists()){
        file1.mkdirs();
    }
    //4.将photo下载到服务器的文件夹内
    //通过拷贝将file的临时文件拷贝过去，但是临时文件还在。
    //FileUtils.copyFile(file, new File(file1, fileFileName));
    //通过剪切将file的临时文件剪切过去，此时临时文件已经不在了。
    file.renameTo(new File(file1, fileFileName));
    return null;
}
public String getUsername() {
    return username;
}
public void setUsername(String username) {
    this.username = username;
}
public File getFile() {
    return file;
}
public void setFile(File file) {
    this.file = file;
}
public String getFileFileName() {
    return fileFileName;
}
public void setFileFileName(String fileFileName) {
    this.fileFileName = fileFileName;
}
public String getFileContentType() {
    return fileContentType;
}
public void setFileContentType(String fileContentType) {
    this.fileContentType = fileContentType;
}
```



### 6.11.2.文件上传限制

struts有默认的文件上传大小，是2M。解除限制有几种方式。

第一种方式：修改struts2中的常量

```xml
<!--第一种方式：修改struts2中的常量，在default.properties中配的struts.multipart.maxSize=2097152-->
<constant name="struts.multipart.maxSize" value="5242880"></constant>
```

第二种方式：在拦截器使用声明中注入参数

虽然是有这种方式，但是不能用，可能是个bug。

```xml
<package name="p1" extends="struts-default">
    <action name="upload" class="com.itheima.web.aciton.UploadAction" method="upload">
        <interceptor-ref name="defaultStack">
            <param name="fileUpload.maxmumSize">31457280</param>
        </interceptor-ref>
        <result>/index.jsp</result>
    </action>
</package>
```

### 6.11.3.限制文件上传类型

1.限制文件扩展名

通过在拦截器使用栈中注入参数，控制允许上传的文件类型；

```xml
<interceptor-ref name="defaultStack">
    <param name="fileUpload.allowedExtensions">jpg,png,bmp</param>
</interceptor-ref> 
```



2.限制文件的MIME类型

通过在拦截器使用栈中注入参数，控制允许上传的文件类型；

```xml
<interceptor-ref name="defaultStack">
    <param name="fileUpload.allowedTypes">image/jpg,image/jpeg,image/png</param>
</interceptor-ref> 
```



3.错误提示

当文件类型不符合要求时会出现错误提示（前提是页面上有写动作错误提示）。如下：

![1556527615220](E:\typora-document\images\1556527615220.png)

为了让提示更加友好，可以这样做：

​	1.编写文件;

​		比如在src路径下编写文件fileUpload_message.properties，内容如下：

```xml
struts.message.error.content.type.not.allowed=\u4E0A\u4F20\u7684\u6587\u4EF6\u7C7B\u578B\u4E0D\u652F\u6301\: {0} "{1}" "{2}" {3}
```



​	2.在struts.xml中配置文件；

```xml
<constant name="struts.custom.i18n.resources" value="com.itheima.web.action.fileupload_message"></constant>
```



### 6.11.4.多文件上传

页面：

```jsp
<s:form action="upload2.action" enctype="multipart/form-data">
    <s:textfield name="username" label="用户名"/>
    <s:file name="file" label="头像"/>
    <s:file name="file" label="头像"/>
    <s:submit value="上传"/>
</s:form>
```



java：

```java
private String username;
private File[] file;
private String[] fileFileName;//上传的文件名，上传字段名称+FileName 注意大小写
private String[] fileContentType;//上传文件的MIME类型，上传字段名称+ContentType,注意大小写

public String upload(){
    //1.拿到ServletContext
    ServletContext servlet = ServletActionContext.getServletContext();
    //2.调用realPath,根据一个虚拟目录获得一个真实目录
    String filePath = servlet.getRealPath("/WEB-INF/files");
    File file1 = new File(filePath);
    //3.检查目录是否存在，如果不存在就创建
    if(!file1.exists()){
        file1.mkdirs();
    }
    //4.将photo放过去
    //通过拷贝将file的临时文件拷贝过去，但是临时文件还在。
    //		FileUtils.copyFile(file, new File(file1, fileFileName));

    //通过剪切将file的临时文件剪切过去，此时临时文件已经不在了。
    for(int i=0;i<file.length;i++){
        file[i].renameTo(new File(file1, fileFileName[i]));
    }
    return null;
}
```



### 6.11.5.文件下载

java:

```java
//注意：为inputstream指定名称时不能用in
private InputStream inputStream;	
public String download() throws Exception{
    //1.找到文件存储路径
    String filePath = ServletActionContext.getServletContext().getRealPath("/WEB-INF/files/download.jpg");
    //2.将文件放入一个inputstream中
    setInputStream(new FileInputStream(filePath));
    //返回成功
    return SUCCESS;
    //有一个叫stream的结果类型为我们把剩下的事情做完
}
public InputStream getInputStream() {
    return inputStream;
}
public void setInputStream(InputStream inputStream) {
    this.inputStream = inputStream;
}
```



struts.xml:

```xml
<action name="download" class="com.itheima.web.aciton.DownloadAction" method="download">
    <result name="success" type="stream">
        <!--给stream的结果类型注入参数：Content-Type  -->
        <param name="contentType">application/octet-stream</param>
        <!-- 告知客户以下载的方式打开 ，下载文件名称为file.jpg-->
        <param name="contentDisposition">attachment;filename=file.jpg</param>
        <!-- 注入字节输入流：取值要写动作类中的set方法名称 -->
        <param name="inputName">inputStream</param>
    </result>
</action>
```



## 6.12.OGNL

### 6.12.1.OGNL简介

OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个单独的开源项目。 Struts2框架使用OGNL作为默认的表达式语言。

### 6.12.2.EL表达式自定义方法

1.写一个普通类，提供一个实现功能的方法，例如：

```java
public class OGNLDemo {
	public static String toUpperCase(String str){
		return str.toUpperCase();
	}
}
```



2.在WEB-INF目录中创建一个扩展名为.tld的xml文件，但文件不能放在classes和lib目录中。内容：

```xml
<taglib xmlns="http://java.sun.com/xml/ns/j2ee" 		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee   http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
	version="2.0">
	<tlib-version>1.0</tlib-version><!-- 指定标签库或方法库版本号 -->
	<short-name>myfn</short-name><!-- 使用的短名称。对应的是taglib指令中的prefix -->
	<!-- uri:把当前的方法库绑定到一个uri地址上，在该网址上不一定存在方法库 -->
	<uri>http://www.itheima.com/functions/myfunction</uri>
	<function><!-- 自定义方法 -->
		<name>touppoercase</name><!-- 方法的名称，是jsp页面上使用的名称 -->
		<!-- 指定执行的类 -->
		<function-class>com.itheima.web.function.MyFunction</function-class>
		<!-- 指定执行的方法。方法名称必须和类中的方法名称保持一致
			注意：当方法有参数和返回值时：参数和返回值必须写类全名（除了基本数据类型）
		-->
		<function-signature>java.lang.String toUpperCase( java.lang.String )
        </function-signature>
	</function>
</taglib>
```



xml命名空间的引用来自于tomcat/webapps/examples/WEB-INF/jsp2下的一个扩张名为.tld的文件。

3.在jsp页面的使用

```jsp
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%@ taglib uri="http://www.itheima.com/functions/myfunction"  prefix="myfn"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>My JSP 'index.jsp' starting page</title>
  </head>
  <body>
    abcde-->ABCDE
    <br/>
    ${myfn:touppoercase("abcde")}
  </body>
</html>
```



EL表达式的限制是在jsp页面只能使用静态方法。

注意：EL表达式原理就是调用了pageContext.findAttribute("name"),查找name的顺序是page(PageContext，即外面的大Map或动作类中设置的属性)--request--valueStack--session-application

### 6.12.3.OGNL的使用

1.首先引入struts2的标签；

```jsp
<%@ taglib uri="/struts-tags" prefix="s"%>
```

2.然后使用

* 2.1.输出值或使用方法

  ```jsp
  <s:property value="OGNL-Expression"/>-OGNL的表达式<br/>
  <s:property value="'OGNL-Expression'"/>-OGNL的字符串（加了单引号）<br/>
  <s:property value="'OGNL-Expression'.length()"/>
  		  -OGNL的字符串调用了获取字符串长度的方法<br/>
  ```

* 2.2.访问静态属性

  ```jsp
  <%--OGNL访问静态属性方式：@全类名@静态属性--%>
  <s:property value="@java.lang.Integer@MAX_VALUE"/><br/>
  ```

* 2.3.访问静态方法

  由于struts2对ognl访问静态方法默认是拒绝的，所以需要在struts.xml中配置一下才可以访问。

  ```xml
  <constant name="struts.ognl.allowStaticMethodAccess" value="true"/>
  ```

  现在可以在jsp中访问静态方法了，与访问静态属性方法相同

  ```jsp
  <s:property value="@java.lang.Math@random()"/><br/>
  ```

* 2.4.OGNL操作map和list

  ```jsp
  <%--
      OGNL操作map与list
    		使用的是s:radio的标签，创建list集合，{}相当于创建list集合，list属性的取值是一个OGNL的表达式
  --%>
  <s:radio name='gender' list="{'男','女'}"/><br/>
  <%--
      使用s:radio创建一个map，#{}表示一个map集合，1和0作为value给radio标签的value赋值，男和女作为key显示在页面
  --%>
  <s:radio name='gender' list="#{'1':'男','0':'女'}"/><br/>
  ```

  

3.OGNL在xml中的使用

```xml
<!-- ${}可以把中间的内容当成一个OGNL表达式对待 -->
<param name="contentDisposition">attachment;
    filename=${@java.net.URLEncoder@encode(filename, "UTF-8")}</param>
```



注意：OGNL表达式,查找name的顺序是page(PageContext)--request--valueStack(根中)--contextMap--session-application,OGNL表达式中如果不写#号时，它会从值栈的栈顶查找对应的属性。如果没有则会去ActionContext中在把value的值当作key去查找。

## 6.13.存取数据

### 6.13.1.ActionContext

这是一个map类型的存储结构

1.在ActionContext中存数据

```java
ActionContext context = ActionContext.getContext();
context.put("contextMap", "hello contextMap");
```



2.在session中存数据

```java
//第一种方式：获取key为isession的map
Map<String, Object> session = context.getSession();
session.put("session1", "hello session1");
//第二种方式：使用原始的HttpSession对象
HttpSession session2 = ServletActionContext.getRequest().getSession();
session2.setAttribute("session2", "hello session2");
```



3.在application中存数据

```java
//第一种方式：获取key为application的map
Map<String, Object> application = context.getApplication();
application.put("application1", "hello application1");
//第二种方式：使用原始的ServletContext对象
ServletContext application1 = ServletActionContext.getServletContext();
application1.setAttribute("application2", "hello application2");
```

4.在jsp页面取值

```jsp
<!-- 使用s:property获取ActionContext的数据，value属性的取值是一个OGNL的表达式 -->
<br/>----------获取大Map的数据--------------<br/>
<!-- 获取外围大map的key,方法是#key名称 -->
<s:property value="#contextMap"/><br/>
<!-- 获取外围大map中小map的key,方法是#大Map的key名称.小map的key名称 -->
<s:property value="#session.session1"/>
<s:property value="#application.application1"/>
```



### 6.13.2.ValueStack

这是一个list的存储结构

1.获取valueStack对象

1.1.获取HttpServletRequest对象，通过它的getAttribute()方法从域中取

```java
/1.获取HttpServletRequest对象
HttpServletRequest request = ServletActionContext.getRequest();
//2.通过它的getAttribute()方法从域中取
ValueStack valueStack1 = (ValueStack)request.getAttribute("struts.valueStack");
```



1.2.先获取ActionContext对象，再取出requestMap，然后通过map的get方法获取

```java
//1.先获取ActionContext对象
ActionContext context = ActionContext.getContext();
//2.再取出requestMap
Map<String, Object> requestMap = (Map<String, Object>) context.get("request");
//3.然后通过map的get方法获取（通过key获取对象的引用）
ValueStack valueStack2 = (ValueStack) requestMap.get("struts.valueStack");
```



1.3.使用ActionContext直接获取对象

```java
ValueStack valueStack3 = context.getValueStack();
```

2.存数据

2.1.用push()方法存数据

```java
valueStack3.push(new Student("test", 21));
```



2.2.用setValue()方法存数据

​	`setValue(String expr, Object value)`,`String expr`--ognl表达式,`Object value`--需要操作的数据,数据存哪里主要看第一个参数是否含有`#`,

第一个参数如果含有#则是操作contextMap中的数据:

```java
valueStack3.setValue("#name", "tom");
```



第一个参数如果不含有#则是操作valueStack中的数据:

```java
valueStack3.setValue("name", "tom");
```



2.3.用set()方法存数据

`set(String key, Object o)`,`String key`-- Map的key,'Object o'--map的value.如果栈顶是一個map元素，则直接把key作为map的key，把Object做为map的value存入，存入的是栈顶;如果栈顶不是一個map元素，则创建一个map元素，把key作为map的key，把Object做为map的value存入，存入的是栈顶

```java
valueStack3.set("test2", new Student("rose", 23));
```



3.在jsp页面取数据

```jsp
<!-- 获取valueStack中的元素
获取ValueStack中的值是直接写属性名字，不需要在前面加#
它是从栈顶向下逐项查找属性名称，一旦查到则停止查找
-->
<s:property value="name"/><br/>
<!-- 获取valueStack指定位置的属性值 -->
<s:property value="[2].name"/>
<!-- 获取通过set方法压入栈顶的rose里的name -->
<s:property value="test2.name"/><br/>
<!-- <s:property/>默认获取栈顶元素 -->
<s:property/>
<s:debug/>
```



![1558598859376](E:\typora-document\images\1558598859376.png)



![1558598765575](E:\typora-document\images\1558598765575.png)



![1558598810165](E:\typora-document\images\1558598810165.png)

第一个页面从第二个页面查找，结果是第三个页面。

`<s:property value="[2].name"/>` 的原理是使用了一个叫cutStack()的方法，这个方法需要1个参数，是[]中的值。如果是2，则这个方法会将栈顶对象减少2个，然后查找name属性，找到第一个并返回，也就是标签显示的结果。

## 6.14.迭代标签

1.s:iterator是struts2的迭代标签；

2.属性详解：

​	begin、end、step和jstl的forEach标签一样；

​	value:要遍历的集合，是个OGNL的表达式；

​	var:取值就是一个字符串，

​			如果写了该属性，则会把var值作为key，把当前遍历的元素作为value，存入ActionContext的大Map中；

​			如果不写该属性，把当前遍历的元素压入栈顶；

​	ststus:遍历时的一些计数信息，

​			int getIndex() 从0开始计数

​			int getCount() 从1开始

​			boolean isFirst() 是否是第一个

​			boolean isLast() 是否是最后一个

​			boolean isOdd() 是否是奇数

​			boolean isEven() 是否是偶数

3.实例

动作类部分：

```java
private List<Student> students;

	public String findAll(){
		students = new ArrayList<Student>();
		students.add(new Student("tom", 21));
		students.add(new Student("rose", 23));
		students.add(new Student("jack", 31));
		return SUCCESS;
	}
	
	public List<Student> getStudents() {
		return students;
	}

	public void setStudents(List<Student> students) {
		this.students = students;
	}
```



jsp页面部分：

```jsp
<table width="500px" border="2" align="center">
    <tr>
        <th>序号</th>
        <th>姓名</th>
        <th>年龄</th>
    </tr>
    <s:iterator value="students" var="s" status="vs">
        <tr>
            <td><s:property value="#vs.index"/></td>
            <td><s:property value="#s.name"/></td>
            <td><s:property value="#s.age"/></td>
        </tr>
    </s:iterator>
</table>
<hr/>
<table width="500px" border="2" align="center">
    <s:iterator value="students" status="vs">
        <tr>
            <td><s:property value="#vs.count"/></td>
            <td><s:property value="name"/></td>
            <td><s:property value="age"/></td>
        </tr>
    </s:iterator>
</table>
```



效果：

![1558926124970](E:\typora-document\images\1558926124970.png)

4.OGNL的投影：添加过滤条件

a."?#":过滤所有符合条件的集合，如users.{?#this.age>19}

​	"^#":过滤第一个符合条件的集合，如users.{^#this.age>19}

​	"$#":过滤最后一个符合条件的集合，如users.{$#this.age>19}

实例：

```jsp
<s:iterator value="students.{?#this.age>22}" status="vs">
    <tr>
        <td><s:property value="#vs.count"/></td>
        <td><s:property value="name"/></td>
        <td><s:property value="age"/></td>
    </tr>
</s:iterator>
```

效果：

![1558926166862](E:\typora-document\images\1558926166862.png)



b.指定输出内容：students.{name}

实例：

```jsp
<table width="500px" border="2" align="center">
    <s:iterator value="students.{name}" status="vs">
        <tr>
            <td><s:property value="#vs.count"/></td>
            <td><s:property /></td>
            <td><s:property /></td>
        </tr>
    </s:iterator>
</table>
```



效果：

![1558927194912](E:\typora-document\images\1558927194912.png)

## 6.15.其他标签

1.s:set

​	value属性:取值是一个OGNL表达式

​	var属性：是一个普通字符串

这个标签是吧value属性的值作为value，吧var属性作为key，然后存到ActionContextMap中

实例：

```jsp
<s:set value="'test'" var="t"></s:set>
```



效果:

![1558937362426](E:\typora-document\images\1558937362426.png)

2.s:action

​	name属性:指定一个动作的名称，但不会执行

​	executeResult属性:指定是否执行动作，取值只有true,false

实例：

```jsp
<s:action name="action1" executeResult="true"></s:action>
```



效果：多了两个debug中间的东西和第一个debug了

![1558937459860](E:\typora-document\images\1558937459860.png)

3.s:if s:elseif s:else

​	test属性：指定判断条件，判定显示的数据

实例:

```jsp
<s:set value="'test11'" var="t"></s:set><br/>
<s:if test="#t=='test'">1</s:if>
<s:elseif test="#t=='test1'">2</s:elseif>
<s:else>3</s:else><br/>
```



效果：

![1558938288940](E:\typora-document\images\1558938288940.png)

4.s:url

​	value属性：将值输出到页面

​	action属性：将动作类的请求地址输出到页面

​	var属性：将action的值作为value，var的值作为key存入ActionContextMap中

实例：

```jsp
<s:url value="action1"></s:url><br/>
<s:url action="action1" var="action"></s:url><br/>
```



效果：

![1558938795490](E:\typora-document\images\1558938795490.png)

实例：

```jsp
<a href="<s:property value='#action'/>">#url</a><br/>
<a href="${pageContext.request.contextPath }/action1.action">pagecontext</a><br/>
```



它可以根据struts配置转换后缀名，如果在struts.xml中配置struts.actionextension，值为html，则可以让第二个实例中的第二条进行跳转并且连接后缀名变为html，第一条不能进行跳转。

效果：

![1558939210997](E:\typora-document\images\1558939210997.png)

在向ActionContextMap中放参数时，action里面还可以配置参数，相当于在连接后加参数。name的值是一个字符串，value的值是一个OGNL表达式。实例：

```jsp
<s:url action="action1" var="action">
    <s:param name="name" value="'tom'"></s:param>
</s:url><br/>
```



效果：

![1558941112753](E:\typora-document\images\1558941112753.png)

## 6.16.几种符号的使用

1.#

a.取用contextMap中的key值时使用，如`<s:property value="#name"/>`；

b.OGNL中创建Map对象时使用，如：`<s:radio list="${'male':'男','female':'女'}"/>`

2.$

a.jsp中el表达式的使用，如`${name}`;

b.在xml配置文件中，编写OGNL表达式时使用，如struts\.xml中：

${@java.net.URLEncoder.encode(filename)}

3.%

在struts2中，有些标签的value属性取值就是一个OGNL表达式，例如

`<s:property value="OGNL Expression" />`

还有一部分标签，value属性的取值就是普通字 符串，例如`<s:textfield value="username"/>`，如果想把一个普通的字符串强制看成时OGNL，就需要使用%{}把字符串套起来。

例如`<s:textfield value="%{username}"/>`。当然在`<s:property value="%{OGNL Expression}" />`也可以使用，但不会这么用。

## 6.17.令牌token

struts2中的令牌可以防止表单的重复提交。

使用它需要在2个地方进行配置，一个是struts.xml，一个是jsp中。

struts.xml：

```xml
<action name="login" class="com.itheima.web.action.TokenAction">
    <interceptor-ref name="defaultStack"></interceptor-ref>
    <interceptor-ref name="tokenSession"></interceptor-ref>
    <!-- <result>/success.jsp</result> 请求转发不行-->
    <result type="redirect">/success.jsp</result>
    <result name="invalid.token">/resubmit.jsp</result>
</action>
```



页面：

```jsp
<s:form action="login">
    <s:token></s:token>
    <s:textfield name="name" label="姓名"/>
    <s:submit value="提交"/>
</s:form>
```



## 6.18.用户管理案例

### 6.18.1.创建数据库与表

### 6.18.2.创建接口并实现

首先创建service层接口，然后创建dao层接口，实现service层并调用dao层接口，借此实现dao层接口。如果需要用到工具类则添加工具类，需要添加jar包添加jar包

### 6.18.3.进行struts工程的准备

添加struts的基础jar包，添加struts.xml，添加struts的核心过滤器

### 6.18.4.添加页面

将页面添加到webroot下，然后启动服务器测试项目有无问题

### 6.18.5.登录

1.在struts.xml中配置登录的动作;

2.编写登录动作类，继承ActionSupport,实现ModelDriven;

3.修改页面，为页面取值；

 # 7.java

## 7.1.加载配置文件的方法

### 7.1.1.Properties

通过jdk提供的java.util.Properties类。

此类继承自java.util.HashTable，即实现了Map接口，所以，可使用相应的方法来操作属性文件，但不建议使用像put、putAll这两个方法，因为put方法不仅允许存入String类型的value，还可以存入Object类型的。因此java.util.Properties类提供了getProperty()和setProperty()方法来操作属性文件，同时使用store或save(已过时)来保存属性值（把属性值写入.properties配置文件）。在使用之前，还需要加载属性文件，它提供了两个方法：load和loadFromXML。
load有两个方法的重载：load(InputStream inStream)、load(Reader reader)，所以，可根据不同的方式来加载属性文件。

可根据不同的方式来获取InputStream，如：

 1、通过当前类加载器的getResourceAsStream方法获取

```java
InputStream inStream = TestProperties.class.getClassLoader().getResourceAsStream("test.properties");  
```



2、从文件获取

 ```java
InputStream inStream = new FileInputStream(new File("filePath"));  
 ```



 3、也是通过类加载器来获取，和第一种一样

```java
InputStream in = ClassLoader.getSystemResourceAsStream("filePath"); 
```



 4、在servlet中，还可以通过context来获取InputStream

```java
InputStream in = context.getResourceAsStream("filePath");  
```



 5、通过URL来获取

```java
URL url = new URL("path");  
InputStream inStream = url.openStream();  
```



 ### 7.1.2.ResourceBundle

通过java.util.ResourceBundle类来读取，这种方式比使用Properties要方便一些。

 1、通过ResourceBundle.getBundle()静态方法来获取（ResourceBundle是一个抽象类），这种方式来获取properties属性文件不需要加.properties后缀名，只需要文件名即可。

 ```java
ResourceBundle resource = ResourceBundle.getBundle("com/mmq/test");
//test为属性文件名，放在包com.mmq下，如果是放在src下，直接用test即可  
String key = resource.getString("username");  
 ```



 2、从InputStream中读取，获取InputStream的方法和上面一样，不再赘述。

```java
ResourceBundle resource = new PropertyResourceBundle(inStream);  
```



 注意：在使用中遇到的最大的问题可能是配置文件的路径问题，如果配置文件入在当前类所在的包下，那么需要使用包名限定，如：test.properties入在com.mmq包下，则要使用com/mmq/test.properties（通过Properties来获取）或com/mmq/test（通过ResourceBundle来获取）；属性文件在src根目录下，则直接使用test.properties或test即可。

文件配置如下：

![properties](E:\typora-document\images\properties.png)



# 8.Hibernate

## 8.1.介绍

![1559557610884](E:\typora-document\images\1559557610884.png)



![1559557700143](E:\typora-document\images\1559557700143.png)

## 8.2.初次使用

1.建立工程；

2.导入jar包；

​		jar包分为四部分，

  * hibernate的核心jar包，即在hibernate文件夹下的hibernate3.jar；

  * hibernate的必须的jar包，即在同路径下/lib/required的jar包；

  * hibernate实现jpa规范的jar包，即同路径下/lib/jpa的jar包；

  * 连接mysql用的jdbc的jar包；

    ![img](E:\typora-document\images\wps1.jpg)

3.创建数据库表；

```mysql
CREATE DATABASE DAY28;
USER DAY28;
CREATE TABLE `day28`.`t_user`( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(20), `password` VARCHAR(20), PRIMARY KEY (`id`) ); 
```



4.建立ORM的映射文件；

​		文件来自hibernate文件夹下的/project/etc/hibernate.cfg.xml,这个是模板文件，将它复制进项目的src路径下即可。内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
 "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
 "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">root</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/day28</property>
        <!--show_sql：操作数据库时会打印sql语句-->
        <property name="show_sql">true</property>
        <!-- "format_sql"：打印sql语句前，对语句进行格式化 -->
        <property name="format_sql">true</property>
        <!-- hbm2ddl.auto:自动生成表结构 -->
        <property name="hbm2ddl.auto">update</property>
        <!-- hibernate.connection.autocommit:自动提交事务 -->
        <property name="hibernate.connection.autocommit">true</property>
		<!-- 引入实体类的ORM映射文件，路径是src后面的部分 -->
        <mapping resource="com/itheima/user/User.hbm.xml"/>
    </session-factory>
</hibernate-configuration>
```



上部新添加的的xml声明标签，中间的自带的dtd的引用，下面自己填的配置。

5.写一个实体类；

编写一个叫User的实体类，有3个属性，id,name,password；

6.编写这个实体类的映射文件；

文件与实体类放在同一路径下，名称是类名User+.hbm.xml，内容是:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.itheima.user.User" table="t_user">
		<id name="id" column="id">
			<generator class="native"></generator>
		</id>
		<property name="name" column="name"></property>
		<property name="password" column="password"></property>
	</class>
</hibernate-mapping>
```



上部新添加的xml声明标签，中部的dtd引用来自于hibernate3.jar包中第一个包的最后一个dtd文件的dtd引用，下部是实体类与表的映射关系；

7.测试

```java
@Test
public void test02(){
    //读取配置文件
    Configuration config = new Configuration().configure();
    //根据配置文件，创建Factory
    SessionFactory factory = config.buildSessionFactory();
    //通过Factory获得操作数据库session对象
    Session session = factory.openSession();
    //操作数据库
    User user = new User();
    user.setName("tom");
    user.setPassword("1234");
    session.save(user);
    //关闭资源
    session.close();
    factory.close();
}
```



## 8.3.api详解

### 8.3.1.Configuration

​		Configuration是用户加载配置文件，Configuration调用configure()方法，加载src路径下hibernate.cfg.xml文件；如果配置文件不符合默认加载规则，我们可以调用configure(file)方法通过文件加载或configure(path)方法

通过路径加载。、

​		Configuration加载映射文件有2种方法，一种可以通过Configuration对象加载，但是不推荐，代码如下：

`configuration.addClass(User.class);` ；推荐的是另一种方式，在hibernate.cfg.xml配置文件中，使用mapping属性引入配置文件，代码如下：`<mapping resource="com/itheima/user/User.hbm.xml"/>`；

### 8.3.2.SessionFactory

​		SessionFactory 是创建session的工厂，根据Configuration配置信息创建SessionFactory的工厂类。通过SessionFactory获得Session有2种结果，一个是通过openSession()获取一个全新的Session对象；另一种是通过getCurrentSession()获取当前线程绑定的Session，这种方式的使用还需要在hibernate.cfg.xml配置文件中配置一下才可以，配置如下：

`<property name="hibernate.current_session_context_class">thread</property>` ,

内部的值暂时是thread。

​		getCurrentSession()类似于使用了ThreadLocal的Connection。

### 8.3.3.Session

​		session的增删改查；

* 增：

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  User user = new User();
  user.setName("tom");
  user.setPassword("1234");
  session.save(user);
  //关闭资源
  session.close();
  factory.close();
  ```



* 删：

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  Transaction transaction = session.beginTransaction();
  transaction.begin();
  //User user = new User();
  //user.setId(1);
  User user = (User)session.get(User.class, 1);
  session.delete(user);
  transaction.commit();
  //关闭资源
  session.close();
  factory.close();
  ```



* 改：

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  Transaction transaction = session.beginTransaction();
  transaction.begin();
  User user = (User)session.get(User.class, 1);
  user.setName("汤姆");
  session.update(user);
  transaction.commit();
  //关闭资源
  session.close();
  factory.close();
  ```

  

* 查-get()方法：这种方式是直接查出来并返回结果

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  User user = (User)session.get(User.class, 2);
  System.out.println(user.toString());
  //关闭资源
  session.close();
  factory.close();
  ```



* 查-load()方法：这种方法是使用代理，先不查，当需要使用对象的属性时才回去查，类似于懒加载技术。

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  User user = (User)session.load(User.class, 2);
  System.out.println(user.toString());
  //关闭资源
  session.close();
  factory.close();
  ```



* 查-HQL语言：hibernate query langage

  Query对象是封装HQL语言的对象，内部封装了查询细节。

  Query对象有list()方法，用于返回多行结果；

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  Query query = session.createQuery("from com.itheima.user.User");
  List<User> list = query.list();
  System.out.println(list.toString());
  //关闭资源
  session.close();
  factory.close();
  ```



​	有uniqueResult()方法，用于返回一行结果；

```java
Query query = session.createQuery("from com.itheima.user.User where id='2'");
User user = (User) query.uniqueResult();
```



有setFirstResult()和setMaxResults()进行分页

```java
Query query = session.createQuery("from com.itheima.user.User");
query.setFirstResult(0);
query.setMaxResults(2);
List<User> user = query.list();
System.out.println(user.toString());
```



* 查-Criteria：与HQL调用方式类似

  同样有list()方法

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  Criteria criteria = session.createCriteria(User.class);
  List<User> list = criteria.list();
  System.out.println(list.toString());
  //关闭资源
  session.close();
  factory.close();
  ```



​	同样有uniqueResult()方法

```java
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.eq("name", "rose"));
User user = (User) criteria.uniqueResult();
System.out.println(user.toString());
```



他还可以设置条件：

```java
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.eq("name", "rose"));//查询name=tom的数据
User user = (User) criteria.uniqueResult();
System.out.println(user.toString());
//----------------------------------------------------------------------------
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.like("name", "%os%"));//查询like '%os%'的数据
List<User> list = criteria.list();
System.out.println(list.toString());
//--------------------------------------------------------------------------
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.gt("id", 1));//查询id>1的数据
List<User> list = criteria.list();
System.out.println(list.toString());
/*  gt >
 * 	lt <
 * 	eq =
 * 	ge >=
 * 	le <=
 *  like
 *  between
 * */
```



​	

* 查-SQLQuery：支持原生的sql语句

  ```java
  Configuration config = new Configuration().configure();
  //根据配置文件，创建Factory
  SessionFactory factory = config.buildSessionFactory();
  //通过Fac|tory获得操作数据库session对象
  Session session = factory.openSession();
  //操作数据库
  SQLQuery query = session.createSQLQuery("select * from t_user");
  query.addEntity(User.class);//如果不加这一句就会list打印出一串地址
  List list = query.list();
  System.out.println(list.toString());
  //关闭资源
  session.close();
  factory.close();
  ```



* 事务相关

  * 开启事务是`session.beginTransaction();`;

  * 提交事务是

    ```java
    Transaction transaction = session.beginTransaction();
    transaction.commit();
    ```

  + 回滚事务是

    ```java
    Transaction transaction = session.beginTransaction();
    transaction.rollback();
    ```



+ evict 将缓存中对象清除；
+ clear 清空一级缓存

```java
User user = session.get(User.class, 1);
session.clear();
User user2 = session.get(User.class, 1);
//结果会打印两次，说明一级缓存被清空了
```



+ refresh() 强制刷新一级缓存中的对象（用于解决缓存与数据库数据不同步的问题）

```java
User user = session.get(User.class, 1);
session.refresh();
//结果会打印两次，说明refresh()会将缓存中的对象与数据库同步，再次发送一次sql语句
```



+ flush() 手动提交一级缓存中的对象

```java
User user = session.get(User.class, 1);
user.setName("tom")
session.flush();
//将一级缓存中的对象立刻提交到数据库
```



* saveOrUpdate():提交或更新数据库

```java
User user = new User();
user.setName("tom");
user.setPassword("1234");
session.saveOrUpdate(user);
//主键生成策略为native时，主键为空时，插入数据库
//主键生成策略为assigned时，主键为空时，报错
User user = new User();
user.setId(1);
user.setName("tomm");
user.setPassword("1234");
session.saveOrUpdate(user);
//主键生成策略为native时，主键不为空时，更新数据库
//主键生成策略为assigned且主键不为空时，根据主键查询数据库并在commit时会根据查询结果的有无进行插入或更新
```



## 8.4.主配置文件详解

### 8.4.1.hbm2ddl.auto

hbm2ddl.auto是自动生成表结构的配置策略；值有4个，分别是update,create,create-drop,validate。

update:最常用的取值，如果当前数据库就不存在表结构则自动创建表结构；

​			  如果存在表结构，且表结构与实体一致，则不做修改；

​			  如果存在表结构，但表结构与实体不一致，则修改表结构，并保留原有列；

create:很少使用的值，无论是否存在表结构，每次启动Hibernate都会重新创建表结构，数据会丢失。

create-drop:极少使用的值，无论是否存在表结构，每次启动Hibernate都会重新创建表结构，

​					  每次关闭Hibernate都会删除表结构，数据会丢失。

validate:很少使用的值，不会自动创建表结构，也不会自动维护表结构，只会校验表结构，如果表结构与实体			   不一致则抛出异常；

### 8.4.2.hibernate.dialect

hibernate.dialect是数据库方言的配置策略，例如MySql的方言，如下：

```xml
<!-- 
   数据库方言的配置策略：hibernate.dialect
   MySql的有三种：
    org.hibernate.dialect.MySQLDialect(一般选最短的)
    org.hibernate.dialect.MySQLInnoDBDialect
    org.hibernate.dialect.MySQLMyISAMDialect-->
<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
```



关于分页，MySql中使用的是limit，而oracle中使用的是rownum.

## 8.5.持久化类

### 8.5.1.编写规则

*  提供一个无参数 public访问控制符的构造器
*  提供一个标识属性，用于映射数据表的主键字段
*  所有属性都要提供public访问控制符的 set  get 方法(javaBean)
*   标识属性应尽量使用基本数据类型的包装类型
*   不要用final修饰实体 （将无法生成代理对象进行优化）

### 8.5.2.持久化对象的唯一标识 OID

 * Java按地址区分同一个类的不同对象

 * 关系数据库用主键区分同一条记录

 * Hibernate使用OID来建立内存中的对象和数据库中记录的对应关系

   结论: 对象的OID和数据库的表的主键对应。为保证OID的唯一性，应该让Hibernate来为OID付值

### 8.5.3.区分自然主键和代理主键

+ 主键需要具备: 不为空/不能重复/不能改变
  		+ 自然主键:	在业务中,某个属性符合主键的三个要求.那么该属性可以作为主键列
    		+ 代理主键: 	在业务中,不存符合以上3个条件的属性,那么就增加一个没有意义的列.作为主键

### 8.5.4.基本数据与包装类型

+ 基本数据类型和包装类型对应hibernate的映射类型相同

+ 基本类型无法表达null、数字类型的默认值为0。

+  包装类默认值是null。当对于默认值有业务意义的时候需要使用包装类。

### 8.5.5.主键生成策略

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<!-- package: 配置该配置文件中类所在的包 -->
<hibernate-mapping package="com.itheima.user">
    <!-- dynamic-insert:默认值是"false"，是否支持动态生成insert语句,该值为true时，
						MySql插入时如果有某一列没有值则不会插入这一列
  		 dynamic-update:默认值是"false",是否支持动态生成update语句 ,该值为true时，
						MySql更新时如果有某一列没有值则不会更新这一列-->
    <class name="User" table="t_user" dynamic-insert="false" dynamic-update="false">
        <!-- unsaved-value:当该属性为该值时，该属性被认为是null而不作处理 
             access:不推荐使用，如果将值设置为field，
            		则hibernate会绕过实体类的get,set方法通过反射直接操作实体类的属性-->
        <id name="id" column="id" unsaved-value="0" access="">
        <!-- generator:主键生成策略，有7个值
                    1.increment 由hibernate自己维护自动增长，底层通过先查询max值，再+1策略
                                不建议使用，存在线程并发问题
                    2.identity  hibernate底层采用数据库本身自动增长列，
                                例如：mysql sqlserver 都是auto_increment
                    3.sequence  hibernate底层采用数据库序列
                                例如：oracle 提供序列
                    4.hilo 	    hibernate自身的一种算法，可以提供生成id的功能
                    5.native    根据底层数据库的能力选择 identity、sequence 或者 hilo 中的一个。
                    ##以上策略使用整形，long, short 或者 int 类型
                    6.uuid 		采用字符串唯一值【】
                    ##以上策略 代理主键，有hibernate维护。
                    7.assigned 	适用于自然主键，由程序自己维护。 -->
            <generator class="native"></generator>
        </id>
        <!-- 
			insert: 默认为true，该属性是否加入insert语句
			update: 默认为true，该属性是否加入update语句
			length: 数据长度
			not-null: 默认为true,该列约束是否是空
			unique: 默认值为false，该列约束是否唯一
			precision: 数字小数位数
			scale: 数字有效数字位数			
		 -->
        <!--
			type:表达数据的类型
				 可以用三种方式指定属性
			java类型        数据库类型           hibernate
			java.lang.String  varchar          string
		-->
        <property name="name" column="name"></property>
        <property name="password" column="password"></property>
    </class>
</hibernate-mapping>
```



type:表达数据的类型

| Java数据类型                       | Hibernate数据类型 | 标准SQL数据类型 (PS:对于不同的DB可能有所差异) |
| ---------------------------------- | ----------------- | --------------------------------------------- |
| byte、java.lang.Byte               | byte              | TINYINT                                       |
| short、java.lang.Short             | short             | SMALLINT                                      |
| int、java.lang.Integer             | integer           | INGEGER                                       |
| long、java.lang.Long               | long              | BIGINT                                        |
| float、java.lang.Float             | float             | FLOAT                                         |
| double、java.lang.Double           | double            | DOUBLE                                        |
| java.math.BigDecimal               | big_decimal       | NUMERIC                                       |
| char、java.lang.Character          | character         | CHAR(1)                                       |
| boolean、java.lang.Boolean         | boolean           | BIT                                           |
| java.lang.String                   | string            | VARCHAR                                       |
| boolean、java.lang.Boolean         | yes_no            | CHAR(1)('Y'或'N')                             |
| boolean、java.lang.Boolean         | true_false        | CHAR(1)('Y'或'N')                             |
| java.util.Date、java.sql.Date      | date              | DATE                                          |
| java.util.Date、java.sql.Time      | time              | TIME                                          |
| java.util.Date、java.sql.Timestamp | timestamp         | TIMESTAMP                                     |
| java.util.Calendar                 | calendar          | TIMESTAMP                                     |
| java.util.Calendar                 | calendar_date     | DATE                                          |
| byte[]                             | binary            | VARBINARY、BLOB                               |
| java.lang.String                   | text              | CLOB                                          |
| java.io.Serializable               | serializable      | VARBINARY、BLOB                               |
| java.sql.Clob                      | clob              | CLOB                                          |
| java.sql.Blob                      | blob              | BLOB                                          |
| java.lang.Class                    | class             | VARCHAR                                       |
| java.util.Locale                   | locale            | VARCHAR                                       |
| java.util.TimeZone                 | timezone          | VARCHAR                                       |
| java.util.Currency                 | currency          | VARCHAR                                       |



## 8.6.对象状态

在Hibernate中，对象有三种状态，他们的定义分别是：

瞬时态/临时态:

+ 1.没有与Hibernate产生关联;
+ 2.与数据库的记录没有产生关联(有关联就是与数据库中的id有对应);

持久态:

+ 1.与Hibernate有关联；
+ 2.对象有ID;

游离态/托管态:

+ 1.没有与Hibernate产生关联;
+ 2.对象有ID;

案例:

```java
@Test
public void test02(){
    //通过Fac|tory获得操作数据库session对象
    Session session = HibernateUtil.openSession();
    //操作数据库
    session.beginTransaction();
    User user = new User();//瞬时态
    user.setName("tom");//瞬时态
    user.setPassword("1234");//瞬时态
    session.save(user);//持久态

    session.getTransaction().commit();//持久态
    //关闭资源
    session.close();//游离态
}
```



对象状态之间的转换：

瞬时转持久：首先建立对象，然后对象调用save()方法即可；

瞬时转游离：首先建立对象，然后为对象指定一个数据库中已有的id；

持久转瞬时：:one: 首先通过session的get()方法得到一个对象，然后关闭session，将对象的id设置为null；

​						:two: 首先通过session的get()方法得到一个对象，然后对象调用evict()方法将对象与session的关联移							 除，再将对象的id设置为null；

持久转游离： :one: 首先通过session的get()方法得到一个对象,然后对象调用evict()方法将对象与session的关联移除;

​					   :two: 首先通过session的get()方法得到一个对象，然后关闭session;

游离转瞬时：首先通过session的get()方法得到一个对象，然后对象调用evict()方法将对象与session的关联移						除，再将对象的id设置为null;

游离转持久：首先通过session的get()方法得到一个对象，然后对象调用evict()方法将对象与session的关联移						除，再通过session更新对象；

## 8.7.一级缓存

学习缓存是为了更深层次的理解Hibernate中对象的操作。Hibernate中存在的缓存是为了提高效率。

Hibernate中缓存存在两种：

+ 线程级别的缓存。session缓存，即本节内容；
+ 进程级别的缓存。Hibernate   二级缓存；

sssion缓存：就是session对象中存在的缓存

一级缓存的快照：在从数据库中取出数据时，会将数据一式两份，一份作为缓存中的对象，一份作为快照中的对象，方便在session提交时作为对比。

​		save()与persist()方法是功能相同名称不同的两个方法。save()过时。

​		HQL查询结果不会使用一级缓存(测试：同一批量查询连续执行查看打印了多少条sql语句)，但是HQL批量查询结果会进入缓存(测试：先是批量查询然后查询结果中包含的一条，看打印了多少条sql语句)。

​		SQL查询结果如果封装进对象里，则会进入一级缓存；没有则不会进入一级缓存。

​		criteria对象与HQL结果一致，查询结果会进一级缓存，但是查询不会使用一级缓存。

## 8.8.多表设计

### 8.8.1.一对多与多对一

1.实体类

多的一方

```java
public class Order {

	private Integer id;
	private String  name;
	
	private Customer customer;
//get、set方法
```



一的一方

```java
public class Customer {

	private Integer id;
	private String  name;
//在1对多中少的一方可通过使用set集合表示多的一方
	private Set<Order> order = new HashSet<Order>();
//get、set方法
```



2.配置实体类的映射文件

Order.hbm.xml

```xml
<hibernate-mapping package="com.itheima.user">
	<class name="Order" table="t_order">
		<id name="id" column="id">
			<generator class="native"></generator>
		</id>
		<property name="name" column="name" type="string"></property>
	<!-- many-to-one: 表示多对一的关系
		 name: 表示引用的属性的名称
		 column: 外键的列名
		 class: 引用的类的完整类名
		  -->
	<many-to-one name="customer" class="Customer" column="cid"></many-to-one>
	</class>
</hibernate-mapping>
```



Customer.hbm.xml

```xml
<hibernate-mapping package="com.itheima.user">
	<class name="Customer" table="t_customer">
		<id name="id" column="id">
			<generator class="native"></generator>
		</id>
		<property name="name" column="name"></property>
	<!-- set: 表示一对多的关系
		 name:集合属性的名称
		 inverse: 是否将关系的维护反转给对方，默认值：false
		 		  值为true时，此方将放弃维护外键关系
		 cascade: 级联操作
		 	save-update: 级联保存，级联修改，保存A同时保存B
		 	delete: 级联删除，删除A同时删除B，则AB都不存在
		 	delete-orphan: 孤儿删除，解除关系，同时将B删除，A存在的；
		 	（同时配置多项需要用逗号分隔，例如：
		 	cascade="save-update,delete"）
		 	all: save-update和delete的整合
		 	all-delete-orphan: 三个的整合
	 -->
	<set name="order" inverse="true" cascade="save-update">
	<!-- key: 用来表示外键
		 column: 外键的值
	-->
		<key column="cid"></key>
		<!-- one-to-many: 用来表示Customer与order的关系
			 class: 表示关联的另一方的完整类名 -->
		<one-to-many class="Order"/>
	</set>
	</class>
</hibernate-mapping>
```



3.多表关系添加

```java
@Test
//多表关系=》增
//前三条打印insert语句，维护对象与外键
//后两句update语句有一次维护外键
//维护对象时，会自动维护另一方的关系
//多次维护解决办法是单纯指定关系由一方来维护，另一方不用维护
//注意： 外键的维护能否放弃只能由非外键的对象来放弃

//维护一方对象时，会自动维护另一方对象
//配置了inverse后，
//删除会报错，因为Customer已经不再维护外键了，直接删除会导致order一方引用无效的id，违反外键的约束
public void test04(){
    //通过Factory获得操作数据库session对象
    Session session = HibernateUtil.openSession();
    //操作数据库
    session.beginTransaction();
    Customer customer = new Customer();
    customer.setName("tom");

    Order order1 = new Order();
    order1.setName("香蕉");
    Order order2 = new Order();
    order2.setName("葡萄");

    //customer.getOrder().add(order1); //配置了inverse后，
    //customer.getOrder().add(order2); //配置了inverse后， 
	order1.setCustomer(customer);
	order2.setCustomer(customer);
    
    session.save(order1);
    session.save(order2);
    session.save(customer);
    session.getTransaction().commit();
    //关闭资源
    session.close();
}
```





4.多表关系删除

```java
Customer customer = (Customer)session.get(Customer.class, 4);
Set<Order> set = customer.getOrder(); //配置了inverse后，
for(Order order: set){ 				  //配置了inverse后，
    order.setCustomer(null);		  //配置了inverse后，
}										
session.delete(customer);
```

5.cascade="save-update"的demo

```java
@Test
public void test06(){
    //通过Factory获得操作数据库session对象
    Session session = HibernateUtil.openSession();
    //操作数据库
    session.beginTransaction();
    Customer customer = (Customer)session.get(Customer.class, 5);
    for(Order order: customer.getOrder()){
        order.setName("西瓜");
    }
    session.getTransaction().commit();
    //关闭资源
    session.close();
}
```



6.cascade="delete"的demo

```java
/*
 * cascade:delete
 * 注意：cascade不能在两边都配置级联删除，否则删除一方，会导致两方都会被删除
* */
@Test
public void test07(){
    //通过Factory获得操作数据库session对象
    Session session = HibernateUtil.openSession();
    //操作数据库
    session.beginTransaction();
    Customer customer = (Customer)session.get(Customer.class, 5);
    session.delete(customer);
    session.getTransaction().commit();
    //关闭资源
    session.close();
}
```

7.cascade="delete"的demo

```java
/*
 * cascade:delete-orphan
 * 
 * */
@Test
public void test08(){
    //通过Factory获得操作数据库session对象
    Session session = HibernateUtil.openSession();
    //操作数据库
    session.beginTransaction();
    Customer customer = (Customer)session.get(Customer.class, 6);
    Iterator<Order> iterator = customer.getOrder().iterator();
    //注意：删除订单时，不可以使用customer.setOrder(null);或customer.setOrder(new HashSet());
    while(iterator.hasNext()){//遍历customer的订单，并将订单删除=>并维护关系
        iterator.next();
        iterator.remove();
    }
    session.getTransaction().commit();
    //关闭资源
    session.close();
}
```



### 8.8.2.多对多





### 8.8.3.一对一

# 9.Maven

## 9.1. Maven的介绍

maven是一款服务于java平台的自动化构建工具

## 9.2.Maven的安装与配置

1.在官网下载Maven，然后解压；

2.配置环境变量。配置M2_HOME或MAVEN_HOME，值为bin目前的路径，然后在Path变量中加入

值%M2_HOME%\bin；

3.测试是否环境变量配置成功，在命令行写入命令`mvn -v` 即可完成测试；

## 9.3.创建Maven工程

### 9.3.1.创建约定的目录结构

	+ 根目录：工程名
	+ src目录：源码
	+ pom.xml文件：Maven工程的核心配置文件
	+ main目录：存放主程序
	+ test目录：存放测试程序
	+ java目录：存放java源文件
	+ resourses目录：存放框架或其他工具的配置文件

目录结构：

Hello

​	|---src

​	|---|---main

​	|---|---|---java

​	|---|---|---resourses

​	|---|---test

​	|---|---|---java

​	|---|---|---resourses

​	|---pom.xml

pom.xml内容

```xml
<?xml version="1.0" ?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                       http://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <modelVersion>4.0.0</modelVersion>  
    <groupId>com.atgui.maven</groupId>  
    <artifactId>Hello</artifactId>  
    <version>0.0.1-SNAPSHOT</version>  
    <name>Hello</name>
    <dependencies>  
        <dependency>  
            <groupId>junit</groupId>  
            <artifactId>junit</artifactId>  
            <version>4.0</version>  
            <scope>test</scope>
        </dependency> 
    </dependencies>  
</project>
```



## 9.4.Maven常用命令

+ 注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在目录。                                                       （与构建过程相关的：编译，打包，测试）

 + 常用命令：
   + mvn clean:清理
   + mvn compile:编译主程序
   + mvn test-compile:编译测试程序
   + mvn test:执行测试
   + mvn package:打包
   + mvn install:安装
   + mvn site:生成站点

## 9.5.Maven仓库

1.开始编译时，Maven核心程序如果在 本地仓库找不到需要的插件，则会自动连接外网，到中央仓库去下载。如果连接失败，则构建失败。可以通过修改本地仓库位置让Maven核心程序在我们事先准备好的的目录下查找插件；

2.修改本地仓库位置步骤：

​	a.找到Maven解压目录\conf\settings.xml;

​	b.在settings.xml中找到localRepository标签；

​	c.将标签从注释中取出，并将内容替换为自己准备好的本地仓库位置，例如：

```xml
<localRepository>D:\Maven</localRepository>
```

3.仓库分类

+ 本地仓库：当前电脑上部署的仓库目录，为当前电脑删给所有的maven工程服务；
+ 远程仓库：
  + 私服：搭建在局域网的环境中，为局域网范围的maven工程服务；
  + 中央仓库：架设在internet上，为全世界的的maven工程服务；
  + 中央仓库镜像：为分担中央仓库流量，提升用户访问速度而在世界各地搭建的仓库；

4.仓库内容：maven工程

+ maven自身需要的插件；
+ 第三方框架或工具的jar包；
+ 自己开发的maven工程；

## 9.6.Maven的核心概念

### 9.6.1.坐标

maven可以使用三个指定坐标唯一定位一个maven工程

+ groupid:公司或组织域名倒序+项目名

  ```xml
  <groupId>com.atguigu.maven</groupId>
  ```

+ artifactid:模块名

  ```xml
  <artifactId>Hello</artifactId>
  ```

  

+ version:版本号

  ```xml
  <version>1.0.0</version>
  ```

maven工程坐标与本地仓库中路径的关系

```xml
<groupId>com.atguigu.maven</groupId>
<artifactId>Hello</artifactId>
<version>1.0.0</version>
```

这个工程在maven仓库路径下/com/atguigu/maven/Hello-1.0.0/Hello-1.0.0.jar

### 9.6.2.依赖管理

1.maven解析依赖信息时会到本地仓库中查找被依赖的jar包

对于自己的maven工程可以使用mvn install命令安装后就可以进入仓库

2.依赖范围scope

compile对主程序有效，对测试程序有效，参与打包

test对主程序无效，对测试程序有效，不参与打包。例如junit

provided对主程序有效，对测试程序有效，不参与打包，不参与部署，例如servlet-api.jar

3.依赖具有传递性

在一个工程里加入Jar包的依赖，所有引用或依赖这个的工程的工程就都有这个依赖了（仅限于scope为compile的），如果某个工程不需要这个依赖，则可以在这个jar包所在依赖里配置如下：

```xml
<exclusions>
	<exclusion>
    	<groupId></groupId>
        <artifactId></artifactId>
    </exclusion>
</exclusions>
```



4.依赖的冲突

情景1：当同一jar包因为依赖的关系有不同版本出现时，maven会采用就近原则，采用路径最短的方式。

a工程中有logging-1.1的依赖，b工程依赖了a工程，而b工程使用的是logging-1.2的依赖，c工程依赖了b工程，此时c工程里有2个版本的logging的依赖，c->b->logging-1.2是2步，c->b->c->logging-1.1是3步，因此采用b工程的jar包。

情景2：在情景1中当路径相同时，采取声明优先原则，采用dependency先声明的。

5.依赖的版本号管理

举例：当依赖spring的多个jar包依赖需要统一升级版本号时，只需在project标签内使用properties标签，并在内部使用自定义标签定义spring同一的版本号，然后在spring的各个依赖的版本号位置version标签内使用`${自定义标签}` 即可统一管理版本号了。

### 9.6.3.生命周期

1. maven各个构建关节不能打乱，必须按照既定的正确顺序来执行；
2. maven的核心程序中定义了抽象的生命周期，生命周期的各个阶段都由插件完成；
3. maven每次自动化构建都会从生命周期的最初的位置开始执行；

### 9.6.4.继承

原因：由于test范围的依赖不能传递，所以必然分散在各个工程模块中，会出现版本不一致，因此需要同一这个依赖的版本；

解决：将这个依赖统一提取到“父工程”中，在子工程中声明这个依赖时不指定依赖版本号，以父工程统一指定为准，便于修改；

操作方法：

1.创建一个maven工程作为父工程，打包方式是pom；

父工程建立后的pom.xml 内容：

```xml
<modelVersion>4.0.0</modelVersion>
<groupId>com.atguigu.maven</groupId>
<artifactId>Parent</artifactId>
<version>0.0.1-SNAPSHOT</version>
<packaging>pom</packaging>
```



2.在子工程中声明对父工程的声明；

对子工程 pom.xml的修改

```xml
<parent>
    <groupId>com.atguigu.maven</groupId>
    <artifactId>Parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>

    <!-- 指定父工程的pom文件 -->
    <relativePath>../Parent/pom.xml</relativePath>
</parent>
```



3.将子工程中的坐标与父工程坐标中重复的内容删除；

对子工程 pom.xml的修改

```xml
<artifactId>Hello</artifactId> 
<!--
删除子工程中
	<groupId>com.atguigu.maven</groupId
    <version>0.0.1-SNAPSHOT</version>
-->
```



4.在父工程统一管理这个依赖；

父工程的修改：

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>  
            <artifactId>junit</artifactId>  
            <version>4.0</version>  
            <scope>test</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```



5.在子工程中删除这个依赖的版本号部分；

删除子工程中关于版本号部分：

```xml
<dependencies>  
    <dependency>  
        <groupId>junit</groupId>  
        <artifactId>junit</artifactId>  
        <scope>test</scope>
    </dependency> 
</dependencies>  
```

### 9.6.5.聚合

作用：一键安装各个模块工程

 配置方式：在一个”总的聚合工程“中配置各个参与聚合的模块

```xml
<modules>
    <module>../Hello</module>
</modules>
```

模块无先后顺序，maven可识别其依赖顺序

使用方式：在聚合工程的pom.xml右键—》run as->maven install

## 9.7.eclipse中的maven

因为maven在eclipse中已经内置，所以只需要进行一下设置即可在eclipse中使用maven。

1.installations:点击右上角添加，选择自己安装的maven路径

![1563779490646](E:\typora-document\images\1563779490646.png)

2.user settings:修改相关路径，更换为自己安装的maven的settings.xml中位置，目的是更换本地仓库位置

![1563779836316](E:\typora-document\images\1563779836316.png)



# 10.Spring

# 11.Mybatis

## 11.1.mybatis入门

​		搭建环境：

   * 创建maven工程，导入坐标；

   * 创建实体类及dao层接口；

   * 创建mybatis的主配置文件SqlMapConfig.xml；

   * 创建映射配置文件IUserDao.xml；

     ​	搭建环境时的注意事项：

* 在mybatis中，他把持久层操作也映射文件叫做Mapper；
* 在idea中创建目录时，包的创建是三级目录，如com.itheima.dao是com->itheima->dao三级目录；目录创建时是一级目录，如com.itheima.dao是com.itheima.dao一级目录；
* mybatis的映射配置文件位置必须和dao接口的包结构相同，如dao接口在com.itheima.dao下，则映射配置文件也要在com.itheima.dao下；
* 映射文件的mapper标签的namespace属性取值必须是dao接口的全限定类名com.itheima.dao.Dao；
* 映射文件的操作配置(select)，id属性的取值必须是dao接口的方法名；

## 11.2.入门案例

```java
public static void main(String[] args) throws Exception{
    //1.读取配置文件
    InputStream  in = Resources.getResourceAsStream("sqlMapConfig.xml");
    //2.创建sqlsessionfactory工厂
    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
    SqlSessionFactory sqlSessionFactory = builder.build(in);
    //3. 使用工厂生产sqlsession对象
    SqlSession session = sqlSessionFactory.openSession();
    //4.使用sqlsession创建dao接口的地代理对象
    IUserDao dao = session.getMapper(IUserDao.class);
    //5.使用代理对象执行方法
    List<User> users = dao.findAll();
    for(User user: users){
        System.out.println(user);
    }
    session.close();
    in.close();
   }
```

mybatis基于注解的入门案例：
把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句
同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。
明确：
我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。
不管使用XML还是注解配置。
但是Mybatis它是支持写dao实现类的。






































































































































[typora使用教程]: https://www.jianshu.com/p/a6a6a22e9393

